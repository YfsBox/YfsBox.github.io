<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="一. 词法分析 词法分析就是将输入的字符流,分解成一个个的单词,并且对每个单词进行归类. 1) token 书中首先介绍了token这一种基本的单位,并且举了几个代码段,来进行说明,其中token常见的几种类型有这些.  对于一段代码如下,经过词法分析器之后可以产生如下的效果:  2) 正则 但是如何从文本(字符序列)解析出一个个的token呢?首先需要介绍的是正则表达式这一形式化的表达方式.正则">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理">
<meta property="og:url" content="http://example.com/2022/111239825.html">
<meta property="og:site_name" content="Yfs&#39;s Box">
<meta property="og:description" content="一. 词法分析 词法分析就是将输入的字符流,分解成一个个的单词,并且对每个单词进行归类. 1) token 书中首先介绍了token这一种基本的单位,并且举了几个代码段,来进行说明,其中token常见的几种类型有这些.  对于一段代码如下,经过词法分析器之后可以产生如下的效果:  2) 正则 但是如何从文本(字符序列)解析出一个个的token呢?首先需要介绍的是正则表达式这一形式化的表达方式.正则">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2010%2007%2012%2051%2040%201665118300%201665118300359%20GVwr10%20image-20221007125140226%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2010%2007%2012%2052%2024%201665118344%201665118344344%20RjtfY0%20image-20221007125224262%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2010%2007%2013%2000%2055%201665118855%201665118855089%20Uy3S6S%20image-20221007130055006%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2010%2007%2013%2010%2031%201665119431%201665119431828%209Fn4Wr%20image-20221007131031745%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2010%2007%2013%2013%2026%201665119606%201665119606812%209jCiTs%20image-20221007131326733%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2004%2022%2001%2038%201667570498%201667570498192%20fr4eBy%20image-20221104220138064%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2015%2027%2042%201668238062%201668238062328%202U68I3%20image-20221112152742227%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2015%2036%2005%201668238565%201668238565100%20aGiW9f%20image-20221112153605011%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2016%2046%2036%201668242796%201668242796474%205jsqE5%20image-20221112164636369%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2016%2056%2058%201668243418%201668243418471%20aWVy1D%20image-20221112165658377%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2013%2018%2014%2038%201668334478%201668334478740%20XQm7tm%20image-20221113181438586%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2017%2040%2031%201668246031%201668246031708%20OhhSlN%20image-20221112174031613%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2018%2000%2019%201668247219%201668247219232%20HPzfut%20image-20221112180019132%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2013%2018%2025%2022%201668335122%201668335122112%20aLCwWp%20image-20221113182522005%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2019%2050%2012%201668253812%201668253812393%20brVzVw%20image-20221112195012284%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2021%2005%2015%201668258315%201668258315569%20gVMhfi%20image-20221112210515455%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2013%2019%2016%2018%201668338178%201668338178168%20ozbHdW%20image-20221113191618033%20.png">
<meta property="article:published_time" content="2022-11-12T06:22:42.000Z">
<meta property="article:modified_time" content="2022-12-19T02:54:15.060Z">
<meta property="article:author" content="yfs">
<meta property="article:tag" content="编译原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2010%2007%2012%2051%2040%201665118300%201665118300359%20GVwr10%20image-20221007125140226%20.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>编译原理</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<link rel="stylesheet" href="/js/prism/prism.css">

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2022/111523193.html"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/11059442.html"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/111239825.html"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/111239825.html&text=编译原理"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/111239825.html&title=编译原理"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/111239825.html&is_video=false&description=编译原理"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=编译原理&body=Check out this article: http://example.com/2022/111239825.html"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/111239825.html&title=编译原理"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/111239825.html&title=编译原理"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/111239825.html&title=编译原理"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/111239825.html&title=编译原理"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/111239825.html&name=编译原理&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/111239825.html&t=编译原理"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80.-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">一. 词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#token"><span class="toc-number">1.1.</span> <span class="toc-text">1) token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">2) 正则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">3) 自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%BD%ACnfa"><span class="toc-number">1.3.1.</span> <span class="toc-text">正则转NFA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nfa%E8%BD%ACdfa"><span class="toc-number">1.3.2.</span> <span class="toc-text">NFA转DFA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%8C%96dfa"><span class="toc-number">1.3.3.</span> <span class="toc-text">最小化DFA</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C.-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">二. 语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%9B%B0%E9%9A%BE"><span class="toc-number">2.1.</span> <span class="toc-text">0. 语法表示的困难</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">1. 上下文无关文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ll%E6%96%87%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">2) LL文法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%8E%E5%B7%A6%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">回溯与左递归问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#first%E5%92%8Cfollow"><span class="toc-number">2.3.2.</span> <span class="toc-text">First和Follow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%A1%A8%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">2.3.3.</span> <span class="toc-text">预测分析表的构建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lr%E6%96%87%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">3) LR文法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lr%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.1.</span> <span class="toc-text">LR语法分析算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lr0%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">LR(0)分析器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89.-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">三. 语义分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%9C%89%E5%85%B3%E6%96%87%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">1) 上下文有关文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.</span> <span class="toc-text">2) 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88tiger%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3) 结合Tiger代码分析实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">3.4.</span> <span class="toc-text">4) 类型检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B.-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95"><span class="toc-number">4.</span> <span class="toc-text">四. 运行时环境与活动记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">1) 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7"><span class="toc-number">4.2.</span> <span class="toc-text">2) 栈帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tiger%E4%B8%AD%E4%B8%8E%E6%A0%88%E5%B8%A7%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">3) Tiger中与栈帧相关的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94.-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">5.</span> <span class="toc-text">五. 中间代码生成</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        编译原理
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">yfs</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-11-12T06:22:42.000Z" itemprop="datePublished">2022-11-12</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="一.-词法分析">一. 词法分析</h2>
<p>词法分析就是将输入的字符流,分解成一个个的单词,并且对每个单词进行归类.</p>
<h3 id="token">1) token</h3>
<p>书中首先介绍了token这一种基本的单位,并且举了几个代码段,来进行说明,其中token常见的几种类型有这些.</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2010%2007%2012%2051%2040%201665118300%201665118300359%20GVwr10%20image-20221007125140226%20.png" alt="image-20221007125140226" style="zoom: 50%;"></p>
<p>对于一段代码如下,经过词法分析器之后可以产生如下的效果:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2010%2007%2012%2052%2024%201665118344%201665118344344%20RjtfY0%20image-20221007125224262%20.png" alt="image-20221007125224262" style="zoom:50%;"></p>
<h3 id="正则">2) 正则</h3>
<p>但是如何从文本(字符序列)解析出一个个的token呢?首先需要介绍的是正则表达式这一形式化的表达方式.正则表达式可以定义某种字符串的格式,对于输入的字符串可以进行匹配,根据是否匹配的结果可以确定给定的字符串是否符合某种类型.关于正则表达式的一些语法上的细节就不再多说.</p>
<blockquote>
<p>在此还是提几个需要注意的细节吧,星号(*)即可重复,表示的是0个或多个.关于“|”则表示必选其一的或.</p>
</blockquote>
<p>下面有几个例子:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2010%2007%2013%2000%2055%201665118855%201665118855089%20Uy3S6S%20image-20221007130055006%20.png" alt="image-20221007130055006" style="zoom:50%;"></p>
<p>还有正则匹配的二义性问题是需要注意的,比如说<code>if8</code>.处理方法有:</p>
<ul>
<li>最长匹配,由于一个字符串可以匹配出多种类型的正则,那么选取其中最长的一种正则类型.(在这里if8就是identifier,虽然也可以匹配到IF关键字和8但是不是最长的).</li>
<li>规则优先,第一匹配完的正则有效.(if8结果为if).</li>
</ul>
<p>但是仅仅是依赖正则表达式还是不够的,正则表达式只能匹配出字符串的类型,但是我们还需要做什么呢?</p>
<blockquote>
<p>一般情况下,词法分析器的作用是用来分析最长匹配.</p>
</blockquote>
<h3 id="自动机">3) 自动机</h3>
<p><strong>我们需要以一种编程模型来实现正则表达式.</strong>所以也就提出了有限自动机的概念.</p>
<p>在词法分析的<strong>有限自动机</strong>中,每个边上的条件对应正则表达式上的一位字符.在运行时,一个字符串将会逐个字符的输入自动机,最终达到终态的就可以接受,如果到达某个非法状态,或者走投无路了,则拒绝该字符串.</p>
<blockquote>
<p>对于某个字符串对一个有穷自动机不匹配的情况:当字符输入完了,但是还没有到达状态机final
state;或者中间某个状态无边可选.</p>
</blockquote>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2010%2007%2013%2010%2031%201665119431%201665119431828%209Fn4Wr%20image-20221007131031745%20.png" alt="image-20221007131031745" style="zoom:33%;"></p>
<p>至此,我们可以根据各种类型的正则表达式得出各自的自动机,但是真正使用时需要一个合并的大的自动机,并且又穷自动机还可以表示成矩阵的形式:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2010%2007%2013%2013%2026%201665119606%201665119606812%209jCiTs%20image-20221007131326733%20.png" alt="image-20221007131326733" style="zoom: 50%;"></p>
<p>在使用自动机进行字符串匹配的过程中,需要记录最长匹配的位置和长度.因此会有两个变量被维护(Last_Final,Input_Position_at_Last_Final).</p>
<p>既然有了一般的自动机,还要NFA有何用呢?其最大的特点在于<strong>非确定,每走一步可以尝试不同的分支(同一个符号).</strong>这也可以用来实现正则表达式.</p>
<p><strong>这一部分的难点在于正则到NFA和NFA到DFA的转换.</strong></p>
<h4 id="正则转nfa">正则转NFA</h4>
<p>首先我们需要明确在正则语法中:**|,·,*是基本的联结运算符号**,因此任何正则表达式都可以转换为只有这3中符号的表达方式,而根据这几种连接符号的性质,我们很容易得出其NFA的表达形式:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2004%2022%2001%2038%201667570498%201667570498192%20fr4eBy%20image-20221104220138064%20.png" alt="image-20221104220138064" style="zoom:33%;"></p>
<p>所以可以将M,N递归地转换成NFA的形式,最终也就可以得到NFA的表达形式.</p>
<h4 id="nfa转dfa">NFA转DFA</h4>
<p>这一部分相对来说要复杂一些.</p>
<p>书上讲得太抽象了,找了篇博客感觉写得挺好:<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43655282/article/details/108963761">NFA到DFA的转化(保证能讲明白)</a>,然后在找几个例子动手写一写,大概就可以理解是怎么一回事了.</p>
<h4 id="最小化dfa">最小化DFA</h4>
<blockquote>
<p>lex是构造词法分析器的强力工具,其输出是一个c语言文件,即根据我们的定义生成的词法分析模块的程序代码.</p>
</blockquote>
<h2 id="二.-语法分析">二. 语法分析</h2>
<blockquote>
<p>语法是将单词组合成词组,从句或者句子的方法.</p>
</blockquote>
<h3 id="语法表示的困难">0. 语法表示的困难</h3>
<p>比如说,我们既然可以将字符以正则的语法组成一个表达式,那么如果我们是不是就可以考虑用一个由token组成的表达式就好了?比如说</p>
<pre class="line-numbers language-none"><code class="language-none">digits = [0-9]+
sum = (digits "+")*digits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对于上面的方式,直接将表达式进行代换就可以得到sum的结果,一个由正则表达式组成的式子.</p>
<p>但是一些表达式的代换需要考虑递归的问题.比如说:</p>
<pre class="line-numbers language-none"><code class="language-none">digits = [0-9]+
sum = expr "+" expr
expr = "(" sum ")" | digits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果考虑直接对sum进行,直接考虑将sum进行代换的话,就会导致无休止的递归问题.</p>
<h3 id="上下文无关文法">1. 上下文无关文法</h3>
<p>上下文无关文法是一个<strong>产生式的集合,还包括一些列开始符,终结符,非终结符等</strong>.每个产生式的格式如下:</p>
<pre class="line-numbers language-none"><code class="language-none">symbol -&gt; symbol symbol ... symbol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>举几个例子:</p>
<pre class="line-numbers language-none"><code class="language-none">S -&gt; aSb
S -&gt; ab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>我们将最左边的S成为非终结符,我们只要找到了符合右边的串,就可以将其归为S.结合书上的例子:</p>
<figure>
<img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2015%2027%2042%201668238062%201668238062328%202U68I3%20image-20221112152742227%20.png" alt="image-20221112152742227">
<figcaption aria-hidden="true">image-20221112152742227</figcaption>
</figure>
<p>以上产生式的集合就可以表示一个文法.终结符是一个产生式中,不可继续分解的最小单位符号.比如上面的num,id,+等等.可以继续分解的就是非终结符.</p>
<p>关于语法的推导,指的是将一个开始符号,对于其右部的每一个非终结符,都用此非终结符产生式中的任意一个右部进行替换,递归地进行,直到无法再进行替换为止,<strong>最终所有非终结符将会消失</strong>,推导有分为<strong>最右推导和最左推导</strong>.如下所示:</p>
<figure>
<img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2015%2036%2005%201668238565%201668238565100%20aGiW9f%20image-20221112153605011%20.png" alt="image-20221112153605011">
<figcaption aria-hidden="true">image-20221112153605011</figcaption>
</figure>
<p>关于推导的过程,<strong>可以将推导的过程组织成一个语法树</strong>.此外,很多文法其实可以最终推导成不同的形式(语法树),称之为<strong>二义性语法</strong>.对于语法二义性应当是我们要避免的东西,因此有一些文法转换的方式.常见的方法有:增加一些非形式化的定义或者设计无二义性的文法.</p>
<blockquote>
<p><strong>文件结束符</strong></p>
<p>文件结束标志往往也是语法分析器必须要读入的,比如说可以用<span class="math inline">\(表示.往往会额外引入一个开始符号S‘,多一个产生式S’
-&gt; S\)</span></p>
</blockquote>
<h3 id="ll文法">2) LL文法</h3>
<p>首先我们需要了解的是,LL文法指的是什么?<strong>LL文法对应了语法树以先序遍历方式,即自顶向下</strong>.</p>
<p>需要明确的是LL文法分析的先决条件:</p>
<ul>
<li>消除左递归问题.</li>
<li>解决回溯问题.</li>
</ul>
<h4 id="回溯与左递归问题">回溯与左递归问题</h4>
<p>对于一个输入的字符串,从开始符号出发,不断地将非终结符进行替换,直到没有非终结符为止,最终建立起一个语法树.最终确定一个推导式.但是容易导致的问题有:</p>
<ul>
<li>在替换的时候,对于同一个非终结符有多种替换方式,并且这其中并非每种替换方式都正确,一旦递归到某地方后发现错误,就需要回溯,然后继续试探.这会带来较大时开销.</li>
<li>左递归所导致的无限循环,如果某一个非终结符可替换的方案中,与该非终结符有共同的前缀,并且始终在递归中无法消除.</li>
</ul>
<p>关于回溯问题的处理,简而言之,<strong>本质是因为某一个非终结符的多个产生式中,具有公共左因子</strong>,因此在制定文法时,需要保证每个非终结符的多个产生式之间不可以有公共左因子.因此可以采用<strong>提取左因子</strong>的方法,如下:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2016%2046%2036%201668242796%201668242796474%205jsqE5%20image-20221112164636369%20.png" alt="image-20221112164636369" style="zoom:50%;"></p>
<p>关于左递归问题的解决.这种现象分为<strong>直接左递归和间接左递归</strong>.定义如下:</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th>直接左递归</th>
<th>文法G中有形如A-&gt;Aa的产生式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>间接左递归</td>
<td>文法G中无形如A-&gt;Aa的产生式,但是可以经过有限步骤得到A-&gt;Aa</td>
</tr>
</tbody>
</table>
<p>关于直接左递归的消除:</p>
<ul>
<li>以产生式中无左递归的部分为前缀,生成右递归表达式.</li>
<li>对于有左递归的部分,去除公共前缀,之后写成右递归的形式(末尾还有一个空符).</li>
</ul>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2016%2056%2058%201668243418%201668243418471%20aWVy1D%20image-20221112165658377%20.png" alt="image-20221112165658377" style="zoom: 33%;"></p>
<p>至于间接左递归的消除方法,首先通过代换的方式,转换成直接左递归问题,然后按照直接左递归进行处理即可.</p>
<h4 id="first和follow">First和Follow</h4>
<p>首先需要了解两个定义:</p>
<ul>
<li>First(a),a是一个给定的符号串,First就是该符号串中的首终结符集合.</li>
<li>Follow(A),是对于非终结符的在整个文法中的后随(紧接的)终结符号的集合.</li>
</ul>
<p>其中对于给定的非终结符A,如何计算其follow集合,需要扫描每个含有A的产生式,描述算法如下:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2013%2018%2014%2038%201668334478%201668334478740%20XQm7tm%20image-20221113181438586%20.png" alt="image-20221113181438586" style="zoom:50%;"></p>
<p>知道Follow大小不再扩张时,Follow构造结束.</p>
<p>其实对于LL文法先决条件的描述,通过Follow和First进行更精确的描述如下,<strong>如果满足这些条件,也就说明没有左递归与回溯</strong>:</p>
<figure>
<img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2017%2040%2031%201668246031%201668246031708%20OhhSlN%20image-20221112174031613%20.png" alt="image-20221112174031613">
<figcaption aria-hidden="true">image-20221112174031613</figcaption>
</figure>
<p>因此,我们需要先求出Follow和First,然后判断是否符合LL的条件.</p>
<h4 id="预测分析表的构建">预测分析表的构建</h4>
<p>下面主要涉及到LL(1)文法有关的部分,LL(1)文法是一种不需要回溯的自顶向下算法.</p>
<p>至此,我们考虑两个问题.一个是,如何构建预测分析表,并且构建出来之后,该预测分析表又是怎么用的呢?关于预测分析表,结构如下:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2018%2000%2019%201668247219%201668247219232%20HPzfut%20image-20221112180019132%20.png" alt="image-20221112180019132" style="zoom:50%;"></p>
<p>每一行对应一个非终结符,每一列对应所有终结符.因此通过检查每个产生式,填表即可.可以参考这个例子<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40741513/article/details/106036849">编译原理LL(1)预测分析表的构造</a>.</p>
<p>描述算法如下:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2013%2018%2025%2022%201668335122%201668335122112%20aLCwWp%20image-20221113182522005%20.png" alt="image-20221113182522005" style="zoom:50%;"></p>
<p>然而预测分析表是怎样在递归下降中使用呢?</p>
<p>这篇文章中对于parsing的过程有很详细的推导:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/spoiledkid/p/13270238.html">编译原理语法分析之LL(1)
parser</a></p>
<p>推导就是一个伴随着字符串的输入而进行入栈和弹栈的过程,每一步入栈对应了一个非终结符的转化,这里转化的过程是根据预测分析表决策的.</p>
<h3 id="lr文法">3) LR文法</h3>
<p>LR(k)分析代表的是,从左到右分析,最右推导,超前查看k个单词.</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2019%2050%2012%201668253812%201668253812393%20brVzVw%20image-20221112195012284%20.png" alt="image-20221112195012284" style="zoom:50%;"></p>
<p>从此图可知,相比LL(1)文法每次查看一个符号就根据预测分析表来对战进行规约或压入,LR文法则是先将符号压入,如果符合规约的条件,再递归地进行规约动作,直到扫描到结束字符,而且此时栈中只有一个S.LR文法对应了语法分析树中的后序遍历.</p>
<p>除此之外,我们还可以发现,栈内的元素+输入缓冲区的内容总是等于一个”规范句型“.</p>
<h4 id="lr语法分析算法">LR语法分析算法</h4>
<p>LR分析器是怎样知道如何移进或者规约的呢?答案是通过有限自动机来进行的.<strong>这种有限自动机是作用于栈的动作的</strong>.</p>
<p>其中如下所示:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2012%2021%2005%2015%201668258315%201668258315569%20gVMhfi%20image-20221112210515455%20.png" alt="image-20221112210515455" style="zoom:50%;"></p>
<p>其中的纵坐标表示的是栈的状态,而横坐标表示的是当前要输入的符号.关于对于其中动作的说明:</p>
<ul>
<li>sn表示的是移进,并且转换到状态n.</li>
<li>rk表示的是规约,根据文法中的规则k依次弹出单词(弹出单词的数量与产生式右半部分相同).然后压入产生式左半部.</li>
</ul>
<p>因此我们的任务也就是,如何根据文法构建出这样的一个状态机.</p>
<figure>
<img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2011%2013%2019%2016%2018%201668338178%201668338178168%20ozbHdW%20image-20221113191618033%20.png" alt="image-20221113191618033">
<figcaption aria-hidden="true">image-20221113191618033</figcaption>
</figure>
<h4 id="lr0分析器">LR(0)分析器</h4>
<h2 id="三.-语义分析">三. 语义分析</h2>
<h3 id="上下文有关文法">1) 上下文有关文法</h3>
<p>为什么需要进行语义分析呢?</p>
<ul>
<li><strong>需要捕获一些Parser捕获不了的错误</strong>.Parser只能从形式上的错误进行捕获(正所谓上下文无关文法).而一些语义上的错误却捕获不了(这种语义上的错误可以认为是上下文有关文法),因此还涉及到类型检查等工作.</li>
<li><strong>对于程序中的Identifiers需要补充一些额外的信息(即符号表)</strong>.这在具体的实现上体现为符号表的构造及其Bindings的设置.</li>
</ul>
<p>然而关于一些语义上的问题,具体都是指什么呢?</p>
<ul>
<li>类型不匹配.</li>
<li>class继承问题.</li>
<li>重复定义问题等等.</li>
</ul>
<p>还有许多不再一一枚举,这些都是与某个语言的具体定义有关的,其本质上也就是<strong>上下文有关文法</strong>.</p>
<h3 id="基本概念">2) 基本概念</h3>
<p>接下来简要说明几个核心的概念:<strong>符号表,绑定,作用域</strong>.</p>
<p>绑定是对于每个Identifier名及其相关信息所组成的数据结构,也就是符号表中的条目.一个Identifier最基本的信息就是类型(究竟是函数,还是变量,还是对象,对于同一种类型的Identifier还可以再往下区分类型,比如说int还是string等等),一般在实现时对于不同的Identifier会有不同类型的绑定,其中的字段也有所不同,比如说对于一个函数类型的绑定中往往会有参数,返回值等等.还有其他比较必要的信息,比如size.</p>
<p>符号表是绑定的集合,一个符号表可以采用不同的数据结构来存储,比如说散列表等等,数据结构的选择是一个重要的问题.符号表在实现时往往会又一些增,删,查相关的接口.</p>
<p>作用域也是和符号表息息相关的,因为绑定的有效性(也就是一个Identifier的生命周期往往是和作用域有关的),比如说当遇到某个变量的声明时,首先将其加入到当前作用域的符号表中,当离开该作用域时,就需要将该Identifier移除,很多Identifier遵循的是“先声明后引用”的原则,因此当对某个Identifier进行处理时都遵循从最近作用域向外部查找的方式.而对于一些语言中的class定义就不同(比如说cool),一般是不遵循“先声明后引用的原则”,因此其在处理上需要额外地先进行全局性地扫描.</p>
<h3 id="结合tiger代码分析实现">3) 结合Tiger代码分析实现</h3>
<p>虎书中介绍了一种基于散列表实现的符号表.</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">TAB_table_</span> <span class="token operator">*</span>S_table<span class="token punctuation">;</span>
S_table <span class="token function">S_empty</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回一个空的符号表</span>
<span class="token keyword keyword-void">void</span> <span class="token function">S_enter</span><span class="token punctuation">(</span>S_table t<span class="token punctuation">,</span> S_symbol sym<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将符号sym加入到当前作用域</span>
<span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">S_look</span><span class="token punctuation">(</span>S_table t<span class="token punctuation">,</span> S_symbol sym<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从符号表t中查找符号Sym,</span>
<span class="token keyword keyword-void">void</span> <span class="token function">S_beginScope</span><span class="token punctuation">(</span>S_table t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进入当前作用域</span>
<span class="token keyword keyword-void">void</span> <span class="token function">S_endScope</span><span class="token punctuation">(</span>S_table t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 离开当前作用域</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中符号表的具体定义如下:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">binder_</span> <span class="token operator">*</span>binder<span class="token punctuation">;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">binder_</span> <span class="token punctuation">{</span>  
  <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span> 
  <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>value<span class="token punctuation">;</span> 
  binder next<span class="token punctuation">;</span> 
  <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>prevtop<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">TAB_table_</span> <span class="token punctuation">{</span>
  binder table<span class="token punctuation">[</span>TABSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>top<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由此可见,TAB_table主要是一个散列表,数组table的每一项对应每一个链表.其中<code>top</code>指针适合维护作用域息息相关的变量,可以说为了实现作用域,还需要维护一个辅助栈,在后续详细说明.</p>
<p>此外还值得一提的是,符号表所接收的参数是<code>S_symbol</code>,这里本应该是一个表示Identifier的字符串,但是这里由于采用了散列,因此还需要实现与该散列相关的Hash函数,其中有关<code>S_symbol</code>的实现如下:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">S_symbol_</span> <span class="token punctuation">{</span>  
  string name<span class="token punctuation">;</span> 
  S_symbol next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">109</span>  </span><span class="token comment">/* should be prime */</span></span>
<span class="token keyword keyword-static">static</span> S_symbol hashtable<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因此我们可以得出这代表的是一个结点,其内容为一个Identifier的name.后面有一些与散列有关的实现.</p>
<p>接下来是一些符号表中的具体操作的实现:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword keyword-void">void</span> <span class="token function">S_enter</span><span class="token punctuation">(</span>S_table t<span class="token punctuation">,</span> S_symbol sym<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">TAB_enter</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>sym<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">S_look</span><span class="token punctuation">(</span>S_table t<span class="token punctuation">,</span> S_symbol sym<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> <span class="token function">TAB_look</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>sym<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">S_symbol_</span> marksym <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"&lt;mark&gt;"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">S_beginScope</span><span class="token punctuation">(</span>S_table t<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token function">S_enter</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span><span class="token operator">&amp;</span>marksym<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">S_endScope</span><span class="token punctuation">(</span>S_table t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  S_symbol s<span class="token punctuation">;</span>
  <span class="token keyword keyword-do">do</span> s<span class="token operator">=</span><span class="token function">TAB_pop</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token operator">&amp;</span>marksym<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>enter</code>是通过直接调用<code>TAB_enter</code>实现的,<code>look</code>同理,<code>S_beginScope</code>的实现是基于<code>S_enter</code>实现的,可以将其理解为向符号表加入一种特殊的符号,也就是<code>&lt;mark&gt;</code>,专门标记一层作用域.关于<code>S_endScope</code>也就是其逆操作,一直pop,直到遇到<code>&lt;mark&gt;</code>标记之外.</p>
<p>至此我们可以简单地推测在更底层的<code>TAB</code>相关的实现中,既要维护散列表,也要维护辅助栈.辅助栈的作用在于可以通过<code>&lt;mark&gt;</code>将入栈的一层层Identifier划分为不同层次的作用域.更多细节如下所示:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword keyword-void">void</span> <span class="token function">TAB_enter</span><span class="token punctuation">(</span>TAB_table t<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> index<span class="token punctuation">;</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>t <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  index <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span><span class="token punctuation">)</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> TABSIZE<span class="token punctuation">;</span>
  t<span class="token operator">-&gt;</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Binder</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span>t<span class="token operator">-&gt;</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token operator">-&gt;</span>top<span class="token punctuation">)</span><span class="token punctuation">;</span>
  t<span class="token operator">-&gt;</span>top <span class="token operator">=</span> key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">TAB_look</span><span class="token punctuation">(</span>TAB_table t<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> index<span class="token punctuation">;</span>
  binder b<span class="token punctuation">;</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>t <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  index<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span><span class="token punctuation">)</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> TABSIZE<span class="token punctuation">;</span>
  <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span>b<span class="token operator">=</span>t<span class="token operator">-&gt;</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> b<span class="token punctuation">;</span> b<span class="token operator">=</span>b<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>b<span class="token operator">-&gt;</span>key<span class="token operator">==</span>key<span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> b<span class="token operator">-&gt;</span>value<span class="token punctuation">;</span>
  <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">TAB_pop</span><span class="token punctuation">(</span>TAB_table t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>k<span class="token punctuation">;</span> binder b<span class="token punctuation">;</span> <span class="token keyword keyword-int">int</span> index<span class="token punctuation">;</span>
  <span class="token function">assert</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
  k <span class="token operator">=</span> t<span class="token operator">-&gt;</span>top<span class="token punctuation">;</span>
  <span class="token function">assert</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
  index <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span><span class="token punctuation">)</span>k<span class="token punctuation">)</span> <span class="token operator">%</span> TABSIZE<span class="token punctuation">;</span>
  b <span class="token operator">=</span> t<span class="token operator">-&gt;</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  t<span class="token operator">-&gt;</span>table<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
  t<span class="token operator">-&gt;</span>top<span class="token operator">=</span>b<span class="token operator">-&gt;</span>prevtop<span class="token punctuation">;</span>
  <span class="token keyword keyword-return">return</span> b<span class="token operator">-&gt;</span>key<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>enter</code>是获取该symbol的散列值之后,将其加入到散列表中,并且直接入栈.对于look来说,直接从散列表中查询即可,而对于pop来说,既要从辅助栈中弹出,也要从散列表中移除.</p>
<p>关于Binding中的具体信息,这些将会在types.h等文件中有所体现,也就对应了<code>binder_</code>中的value,由于使用了void*,因此可以实现一种类似于多态的机制:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">Ty_ty_</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-enum">enum</span> <span class="token punctuation">{</span>
    	Ty_record<span class="token punctuation">,</span> 
    	Ty_nil<span class="token punctuation">,</span> 
    	Ty_int<span class="token punctuation">,</span> 
    	Ty_string<span class="token punctuation">,</span> 
    	Ty_array<span class="token punctuation">,</span> 
    	Ty_name<span class="token punctuation">,</span> 
    	Ty_void<span class="token punctuation">}</span> kind<span class="token punctuation">;</span>
	<span class="token keyword keyword-union">union</span> <span class="token punctuation">{</span>
    			Ty_fieldList record<span class="token punctuation">;</span>
		      Ty_ty array<span class="token punctuation">;</span>
		      <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
            	S_symbol sym<span class="token punctuation">;</span> 
            	Ty_ty ty<span class="token punctuation">;</span>
          <span class="token punctuation">}</span> name<span class="token punctuation">;</span>
		    <span class="token punctuation">}</span> u<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="类型检查">4) 类型检查</h3>
<p><strong>类型检查实际上是在遍历AST的过程中进行的.</strong>这个过程中需要更新和查看符号表.也就需要用到上面所介绍的接口.cs143的课程中还介绍到了类型检查有关的形式化表示,在此不再多说.在此主要叙述类型检查的实现.</p>
<h2 id="四.-运行时环境与活动记录">四. 运行时环境与活动记录</h2>
<h3 id="概述">1) 概述</h3>
<p>​
运行时环境以及活动记录的作用是什么呢?我们需要管理运行时资源(变量,对象等等),动态数据和静态数据,以及存储管理等等.当一个程序被载入到内存中时,其内存视图可以大致分为代码段和数据段,因此编译器有一个任务也就是<strong>生成代码段中的内容并且填充数据段</strong>.</p>
<p>​
此外关于代码段中代码的执行,一般来说都是从某个点中开始进入,然后顺序执行指令,但是程序中都有像函数这样的过程抽象,如果想要实现“过程”这一概念,就不能只借助代码段中的顺序执行,因为过程的特点就是进入到一个函数后,结束后在恢复现场,因此就引入了程序动态内存区中的栈这一概念.<strong>栈是为了实现程序运行中的过程抽象.</strong></p>
<p>​
此外,代码段在程序中通常在建立之后就处于固定并且只读的状态,静态数据段中的变量都有着固定的地址(在程序初始化时就建立了,并且size通常也固定),栈和堆都处于动态的内存区之中,两者相冲增长,碰撞是应该避免的事情.</p>
<p>​
关于栈这种数据结构,在之前的学习中已经非常熟悉了,在此只梳理一下栈帧.</p>
<h3 id="栈帧">2) 栈帧</h3>
<h3 id="tiger中与栈帧相关的实现">3) Tiger中与栈帧相关的实现</h3>
<h2 id="五.-中间代码生成">五. 中间代码生成</h2>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80.-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">一. 词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#token"><span class="toc-number">1.1.</span> <span class="toc-text">1) token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">2) 正则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">3) 自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%BD%ACnfa"><span class="toc-number">1.3.1.</span> <span class="toc-text">正则转NFA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nfa%E8%BD%ACdfa"><span class="toc-number">1.3.2.</span> <span class="toc-text">NFA转DFA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%8C%96dfa"><span class="toc-number">1.3.3.</span> <span class="toc-text">最小化DFA</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C.-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">二. 语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%9B%B0%E9%9A%BE"><span class="toc-number">2.1.</span> <span class="toc-text">0. 语法表示的困难</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">1. 上下文无关文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ll%E6%96%87%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">2) LL文法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%8E%E5%B7%A6%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">回溯与左递归问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#first%E5%92%8Cfollow"><span class="toc-number">2.3.2.</span> <span class="toc-text">First和Follow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%A1%A8%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">2.3.3.</span> <span class="toc-text">预测分析表的构建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lr%E6%96%87%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">3) LR文法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lr%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.1.</span> <span class="toc-text">LR语法分析算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lr0%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">LR(0)分析器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89.-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">三. 语义分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%9C%89%E5%85%B3%E6%96%87%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">1) 上下文有关文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.</span> <span class="toc-text">2) 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88tiger%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3) 结合Tiger代码分析实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">3.4.</span> <span class="toc-text">4) 类型检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B.-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95"><span class="toc-number">4.</span> <span class="toc-text">四. 运行时环境与活动记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">1) 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7"><span class="toc-number">4.2.</span> <span class="toc-text">2) 栈帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tiger%E4%B8%AD%E4%B8%8E%E6%A0%88%E5%B8%A7%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">3) Tiger中与栈帧相关的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94.-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">5.</span> <span class="toc-text">五. 中间代码生成</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/111239825.html"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/111239825.html&text=编译原理"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/111239825.html&title=编译原理"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/111239825.html&is_video=false&description=编译原理"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=编译原理&body=Check out this article: http://example.com/2022/111239825.html"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/111239825.html&title=编译原理"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/111239825.html&title=编译原理"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/111239825.html&title=编译原理"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/111239825.html&title=编译原理"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/111239825.html&name=编译原理&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/111239825.html&t=编译原理"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    yfs
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
      --><li><a href="/">首页</a></li><!--
    --><!--
      --><li><a href="/about/">关于</a></li><!--
    --><!--
      --><li><a href="/archives/">归档</a></li><!--
    -->
      </ul>
      <ul>
        
          <!-- 不蒜子统计 -->
          <span id="busuanzi_container_site_pv">
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
          </span>
          <span class="post-meta-divider">|</span>
          <span id="busuanzi_container_site_uv" style='display:none'>
                  本站访客数<span id="busuanzi_value_site_uv"></span>人
          </span>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        
      </ul>
    </nav>
  </div>
  
</footer>

<script src="/js/prism/prism.js" async></script>


    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'cactus-1';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'owner/githubrepo';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>
