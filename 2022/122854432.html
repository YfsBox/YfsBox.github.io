<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="0. LLVM基础 1) 系统总览  其中关于LLVM优化器是又一个个Pass所组成的, 每一个Pass根据IR分析收集一些信息, 进而调整IR达到优化的效果.LLVM有一套虚拟指令集, 看上去类似于汇编语言的伪代码, LLVM IR的形式与此有关. 其中Clang的结果是一个AST树, 比如说对于代码: int main() { 	int a &#x3D; 5;   int b &#x3D; 3;   return">
<meta property="og:type" content="article">
<meta property="og:title" content="编译器后端以及优化相关的基础理论">
<meta property="og:url" content="http://example.com/2022/122854432.html">
<meta property="og:site_name" content="Yfs&#39;s Box">
<meta property="og:description" content="0. LLVM基础 1) 系统总览  其中关于LLVM优化器是又一个个Pass所组成的, 每一个Pass根据IR分析收集一些信息, 进而调整IR达到优化的效果.LLVM有一套虚拟指令集, 看上去类似于汇编语言的伪代码, LLVM IR的形式与此有关. 其中Clang的结果是一个AST树, 比如说对于代码: int main() { 	int a &#x3D; 5;   int b &#x3D; 3;   return">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2022%2047%2029%201672411649%201672411649577%20iTZdT5%20image-20221230224729484%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2022%2052%2014%201672411934%201672411934369%20yyMlMP%20image-20221230225214291%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2023%2002%2044%201672412564%201672412564803%20hVlKhd%20image-20221230230244724%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2023%2026%2017%201672413977%201672413977642%208b1bQT%20image-20221230232617555%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2023%2028%2024%201672414104%201672414104334%20WtmdH6%20image-20221230232824248%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2023%2040%2038%201672414838%201672414838969%208EyU0D%20image-20221230234038887%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2029%2010%2043%2017%201672281797%201672281797723%20rcZGkf%20image-20221229104317584%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2029%2011%2002%2019%201672282939%201672282939730%200PBnwu%20image-20221229110219635%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2029%2011%2011%2035%201672283495%201672283495232%20rQFziU%20image-20221229111135143%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2029%2011%2025%2010%201672284310%201672284310778%20kk9029%20image-20221229112510693%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2017%2030%2044%201672392644%201672392644690%209F73ol%20image-20221230173044558%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2017%2040%2048%201672393248%201672393248399%20kg4JtF%20image-20221230174048309%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2017%2052%2023%201672393943%201672393943096%20uC3P7m%20image-20221230175222999%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2020%2032%2051%201672403571%201672403571596%20ac9zE3%20image-20221230203251499%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2020%2038%2011%201672403891%201672403891210%20KVvooS%20image-20221230203811120%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2020%2048%2025%201672404505%201672404505596%20RVd5PB%20image-20221230204825499%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2020%2059%2052%201672405192%201672405192418%20nxm03a%20image-20221230205952326%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2020%2051%2018%201672404678%201672404678809%20Qc2ql6%20image-20221230205118710%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2011%2017%2040%201672456660%201672456660312%204CyVo9%20image-20221231111740233%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2011%2024%2041%201672457081%201672457081075%20yW6KuC%20image-20221231112440999%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2011%2038%2024%201672457904%201672457904741%2032rQjt%20image-20221231113824658%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2012%2051%2035%201672462295%201672462295336%201sj5eg%20image-20221231125135249%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2012%2057%2044%201672462664%201672462664576%20TLVScl%20image-20221231125744494%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2013%2018%2030%201672463910%201672463910249%20AIYzU3%20image-20221231131830163%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2013%2031%2011%201672464671%201672464671033%20mKszue%20image-20221231133110940%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2013%2043%2007%201672465387%201672465387355%20GrPwX3%20image-20221231134307261%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2013%2049%2003%201672465743%201672465743789%20U0yAnZ%20image-20221231134903709%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2004%2023%2012%2007%201672845127%201672845127423%20nyNhVu%20image-20230104231207297%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2004%2022%2039%2016%201672843156%201672843156548%20Z56hDO%20image-20230104223916416%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2004%2022%2039%2049%201672843189%201672843189846%20Qns06s%20image-20230104223949762%20.png">
<meta property="article:published_time" content="2022-12-28T12:35:44.000Z">
<meta property="article:modified_time" content="2023-01-07T04:06:44.363Z">
<meta property="article:author" content="yfs">
<meta property="article:tag" content="编译原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2022%2047%2029%201672411649%201672411649577%20iTZdT5%20image-20221230224729484%20.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>编译器后端以及优化相关的基础理论</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<link rel="stylesheet" href="/js/prism/prism.css">

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2022/12294483.html"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/12251725.html"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/122854432.html"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/122854432.html&text=编译器后端以及优化相关的基础理论"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/122854432.html&title=编译器后端以及优化相关的基础理论"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/122854432.html&is_video=false&description=编译器后端以及优化相关的基础理论"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=编译器后端以及优化相关的基础理论&body=Check out this article: http://example.com/2022/122854432.html"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/122854432.html&title=编译器后端以及优化相关的基础理论"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/122854432.html&title=编译器后端以及优化相关的基础理论"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/122854432.html&title=编译器后端以及优化相关的基础理论"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/122854432.html&title=编译器后端以及优化相关的基础理论"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/122854432.html&name=编译器后端以及优化相关的基础理论&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/122854432.html&t=编译器后端以及优化相关的基础理论"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#llvm%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">0. LLVM基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">1) 系统总览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#llvm-program-structure"><span class="toc-number">1.2.</span> <span class="toc-text">2) LLVM Program Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#more-on-the-llvm-compiler"><span class="toc-number">1.3.</span> <span class="toc-text">3) More on the LLVM Compiler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#data-structures"><span class="toc-number">1.3.1.</span> <span class="toc-text">Data Structures</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class-hierarchy"><span class="toc-number">1.3.2.</span> <span class="toc-text">Class Hierarchy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#casting-and-type-introspection"><span class="toc-number">1.3.3.</span> <span class="toc-text">Casting and Type
Introspection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iterators"><span class="toc-number">1.3.4.</span> <span class="toc-text">Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#visitor-pattern"><span class="toc-number">1.3.5.</span> <span class="toc-text">Visitor Pattern</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E4%BC%98%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">1. 局部优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#value-numbering"><span class="toc-number">2.1.</span> <span class="toc-text">1) Value Numbering</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95lvm%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">拓展LVM算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Edag%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text">2) 基于DAG的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%B1%80%E9%83%A8%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">寻找局部公共子表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E6%AD%BB%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">消除死代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E6%95%B0%E6%81%92%E7%AD%89%E5%BC%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">代数恒等式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">2. 数据流分析基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B0%E8%BE%BE-%E5%AE%9A%E5%80%BC%E5%88%86%E6%9E%90"><span class="toc-number">3.1.</span> <span class="toc-text">1) 到达-定值分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E8%B7%83%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">2) 活跃分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">3) 可用表达式分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">3. 静态单赋值形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">4. 循环优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%85%E7%BB%8F%E7%BB%93%E7%82%B9"><span class="toc-number">5.1.</span> <span class="toc-text">1) 必经结点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%BF%85%E7%BB%8F%E7%BB%93%E7%82%B9%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">寻找必经结点的算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%BF%85%E7%BB%8F%E7%BB%93%E7%82%B9"><span class="toc-number">5.1.2.</span> <span class="toc-text">直接必经结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.1.3.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%89%8D%E7%BD%AE%E7%BB%93%E7%82%B9"><span class="toc-number">5.1.4.</span> <span class="toc-text">循环前置结点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E9%87%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">5.2.</span> <span class="toc-text">2) 循环不变量计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E5%86%97%E4%BD%99%E6%B6%88%E9%99%A4"><span class="toc-number">6.</span> <span class="toc-text">5. 部分冗余消除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%83%B0%E4%BB%A3%E7%A0%81%E7%A7%BB%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-number">6.0.1.</span> <span class="toc-text">懒惰代码移动问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%E4%B8%8E%E6%8C%87%E6%B4%BE"><span class="toc-number">7.</span> <span class="toc-text">6. 寄存器分配与指派</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">1) 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6"><span class="toc-number">7.2.</span> <span class="toc-text">2) 合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E7%9D%80%E8%89%B2%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-number">7.3.</span> <span class="toc-text">3) 预着色的结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9D%80%E8%89%B2%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.4.</span> <span class="toc-text">4) 图着色相关实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference"><span class="toc-number">8.</span> <span class="toc-text">Reference</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        编译器后端以及优化相关的基础理论
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">yfs</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-12-28T12:35:44.000Z" itemprop="datePublished">2022-12-28</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="llvm基础">0. LLVM基础</h2>
<h3 id="系统总览">1) 系统总览</h3>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2022%2047%2029%201672411649%201672411649577%20iTZdT5%20image-20221230224729484%20.png" style="zoom:50%;"></p>
<p>其中关于LLVM优化器是又一个个Pass所组成的,
每一个Pass根据IR分析收集一些信息,
进而调整IR达到优化的效果.LLVM有一套虚拟指令集,
看上去类似于汇编语言的伪代码, LLVM IR的形式与此有关.</p>
<p>其中Clang的结果是一个AST树, 比如说对于代码:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-int">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-int">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-return">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以得到如下形式的AST树:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2022%2052%2014%201672411934%201672411934369%20yyMlMP%20image-20221230225214291%20.png" style="zoom: 50%;"></p>
<p>完整的LLVM编译阶段:<strong>Source code —&gt; Clang AST —&gt; LLVM
IR—&gt; SelectionDAG—&gt;MachineInst—&gt;MCInst/Assembly</strong></p>
<h3 id="llvm-program-structure">2) LLVM Program Structure</h3>
<p>主要涉及到以下四个主要概念:</p>
<ul>
<li>Module.
包含了一些Functions和GlobalVariables,可以视为对一整个程序的抽象.</li>
<li>Function.
包含了一些基本块以及参数.这个概念和C语言中的概念是非常像的.</li>
<li>BasicBlock, 只一连续的指令所组成的代码段,
不涉及到分支、跳转、条件,只要一个Block被执行,
其中所有指令都会执行到.</li>
<li>Instruction, 相当于一个个指令.</li>
</ul>
<p>下面的这个图总结的很直观:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2023%2002%2044%201672412564%201672412564803%20hVlKhd%20image-20221230230244724%20.png" alt="image-20221230230244724" style="zoom: 50%;"></p>
<h3 id="more-on-the-llvm-compiler">3) More on the LLVM Compiler</h3>
<h4 id="data-structures">Data Structures</h4>
<p>首先需要提到的是string,
为什么不推荐常规C/C++程序一样直接使用char*或者std::string, 作为字符串呢?
因为前者使用了'\0'表示字符串末尾,
这种方式对于字节字符串来说是不太合适的.至于后者在性能上不是太优秀.其使用方式大致如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">StringRef</span><span class="token punctuation">(</span><span class="token string">"myfunc"</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>
std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"myfunc"</span><span class="token punctuation">)</span> <span class="token comment">//相当于</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果使用.str()可以获取其对应的std::string.此外关于输入输出“std::cout”应该使用的是outs(),errs(),null()等.如下所示:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2023%2026%2017%201672413977%201672413977642%208b1bQT%20image-20221230232617555%20.png" alt="image-20221230232617555" style="zoom:50%;"></p>
<p>不仅仅如此, 相比C++中的STL, 比较建议使用的是LLVM提供的一些数据结构,
其中包含这些:</p>
<pre class="line-numbers language-none"><code class="language-none">ImmutableSet, IntervalMap, IndexedMap, MapVector, PriorityQueue, 
SetVector, ScopedHashTable, SmallBitVector, SmallPtrSet, SmallSet, 
SmallString, SmallVector, SparseBitVector, SparseSet, StringMap, StringRef,StringSet, Triple, TinyPtrVector, PackedVector, FoldingSet, UniqueVector,ValueMap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="class-hierarchy"><strong>Class Hierarchy</strong></h4>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2023%2028%2024%201672414104%201672414104334%20WtmdH6%20image-20221230232824248%20.png" alt="image-20221230232824248" style="zoom:50%;"></p>
<h4 id="casting-and-type-introspection">Casting and Type
Introspection</h4>
<p>除此之外,
还有<code>isa&lt;Argument&gt;(v), cast&lt;Argument&gt;(v), dyn_cast&lt;Argument&gt;(v)</code>等比较重要.这三者分别相当于判断v是否是一个Argument
class对象、static_cast、dynamic_cast等等.</p>
<h4 id="iterators">Iterators</h4>
<p>其中包含Module::iterator, Function::iterator, BasicBlock::iterator,
Value::use_iterator, User::op_iterator.相关的使用实例代码如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>Function<span class="token double-colon punctuation">::</span>iterator FI <span class="token operator">=</span> func<span class="token operator">-&gt;</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> FI <span class="token operator">!=</span> func<span class="token operator">-&gt;</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>FI<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>BasicBlock<span class="token double-colon punctuation">::</span>iterator BBI <span class="token operator">=</span> FI<span class="token operator">-&gt;</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> BBI <span class="token operator">!=</span> FI<span class="token operator">-&gt;</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>BBI<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">outs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> “Instruction<span class="token operator">:</span> ” <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>BBI <span class="token operator">&lt;&lt;</span> “\n”<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>inst_iterator I <span class="token operator">=</span> <span class="token function">inst_begin</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">,</span> E <span class="token operator">=</span> <span class="token function">inst_end</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">;</span> I <span class="token operator">!=</span> E<span class="token punctuation">;</span> <span class="token operator">++</span>I<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		<span class="token function">outs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>I <span class="token operator">&lt;&lt;</span> “\n”<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外还有其他使用建议:</p>
<ul>
<li>主要遍历对象时的修改, 这些iterator都是no const的.</li>
<li>最好用++i而不是i++.</li>
</ul>
<h4 id="visitor-pattern">Visitor Pattern</h4>
<p>这里还介绍了一种常用的访问者模式的设计模式.
对于给定的对象(比如说Module,
Function等)我们通过专门设计的一个class来对这些进行访问, 也可以进行修改.
这种类会实现一些函数来访问特定的对象,
这些函数往往使用引用类型的参数.实例代码如下:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2023%2040%2038%201672414838%201672414838969%208EyU0D%20image-20221230234038887%20.png" alt="image-20221230234038887" style="zoom: 50%;"></p>
<p>LLVM中也提供了一些API用来对IR进行增加删除等修改操作.</p>
<h2 id="局部优化">1. 局部优化</h2>
<p>局部优化指的是局限于单个basic
block之中的优化方法.这其中涉及到的最最基础的概念就是<strong>Basic
block和Flow graph, 前者是三地址语句的序列,
后者是以基本块作为节点的图</strong>.其中前者的更准确的定义是:不涉及到跳转、分支、条件,
只会顺序执行的最长代码段.
后者通过图的方式描述了各block之间的流动状况.</p>
<p>主要介绍两种方法, 第一种是value numbering.通过查找basic
block中的冗余表达式, 如果冗余的表达式有相同的计算结果,
那么就将其重用即可. 第二种方式是基于DAG的方法.</p>
<h3 id="value-numbering">1) Value Numbering</h3>
<p>如何判断一个程序块中的表达式冗余呢?
首先起码在形式上完全相同.比如说下列中的:</p>
<pre class="line-numbers language-none"><code class="language-none"># 重写前
a &lt;- b + c
b &lt;- a - d
c &lt;- b + c
d &lt;- a - d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>就比如说上面就有两对符合这种特征的, 但是其中只有a -
d才可以说是符合冗余的.因为还有一个重要的特征,
即<strong>相同的表达式之间, 其中没有发生参数又被赋值的情况</strong>,
比如说b+c中, 其中在第二行出现了对b的赋值, 因此b +
c就不算是冗余表达式.所以总的来说, 冗余的表达式特点如下:</p>
<ul>
<li>形式相同.</li>
<li>每两者之间没有发生参数被赋值的操作.</li>
</ul>
<p>因此可以重写为:</p>
<pre class="line-numbers language-none"><code class="language-none"># 重写后
a &lt;- b + c
b &lt;- a - d
c &lt;- b + c
d &lt;- b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但其实冗余还有更加复杂的情况, 比如说“形式不同”的情况,
就如同下面的代码中:</p>
<pre class="line-numbers language-none"><code class="language-none">a &lt;- b * c
d &lt;- b
e &lt;- d * c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其中形式不同, 但其实也符合冗余的特点,
也应该进行优化.因此其实冗余表达式的查找和判断不是一件容易的事,
因此需要考虑设计新的方法.在这里主要介绍的是Local Value
Numbering,下面简称LVM.下面简要说明该方法.</p>
<p>该方法<strong>需要用一个map表示将name, const,
expression映射到值编号.</strong>最初是空的.在LVM中,
其输入是一个三地址表达式序列, 可以代表一个基本块.在进行计算时,
顺序地遍历该序列,对于每个表达式, 首先查找L和R是否处于map中,
如果有就使用其编号就可以,
没有的话就对其分配一个(从0开始自增).之后再给予“value(L) op
value(R)”来产生一个散列key, 并在map中查找, 如果有,表示该表达式冗余,
直接使用之前的所求的value就可以.否则对这个key分配一个新的编号,还需要对其对应参数的value进行替换.其中伪代码描述如下:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2029%2010%2043%2017%201672281797%201672281797723%20rcZGkf%20image-20221229104317584%20.png"></p>
<p>其中有具体例子如下:</p>
<pre class="line-numbers language-none"><code class="language-none">a &lt;- b + c # value(b) = 0, value(c) = 1, value(0+1) = 2, value(a) = 2
b &lt;- a - d # value(a) = 2, value(d) = 3, value(2-3) = 4, value(b) = 4
c &lt;- b + c # value(b) = 4, value(c) = 1, value(4+1) = 5, value(c) = 5
d &lt;- a - d # value(a) = 2, value(d) = 3, value(2-3) = 4, value(d) = 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中发现value(2-3)前后一样,
因此判断为冗余的表达式.判断出后,便进行重写.</p>
<h4 id="拓展lvm算法">拓展LVM算法</h4>
<ul>
<li><strong>交换运算</strong>对于一些可交换的运算来说, 比如说a + b和b +
a,两个表达式的应该被视为相同的key,
如果说这两个表达式所产生的key分别是0+1和1+0, 对于可交换运算来说,
应该采用某种方式统一次序, 进而可以以统一的方式代入map.</li>
<li><strong>常量合并</strong>.</li>
</ul>
<p>关于对冗余代码进行重写时, 还有一个问题, 比如说下面的这种情况:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2029%2011%2002%2019%201672282939%201672282939730%200PBnwu%20image-20221229110219635%20.png" alt="image-20221229110219635" style="zoom:50%;"></p>
<p>可以确定第1, 2, 4行的式子是冗余的, 但是当需要重写时,
第四行的式子不能重写为c &lt;- a.因为a已经被修改.应对这种问题,
可以增加一个从编号到name到map.当某个name的编号经过赋值而发生改变时,
就将其所属编号list移动到另一个编号list.当需要进行重写时,
就通过该map查找对应的编号下的list就可以了.</p>
<p>另一种方法如下, 每次对某个值进行重新设置编号时,
就分配一个新的name.比如说:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2029%2011%2011%2035%201672283495%201672283495232%20rQFziU%20image-20221229111135143%20.png" alt="image-20221229111135143" style="zoom:50%;"></p>
<h3 id="基于dag的优化">2) 基于DAG的优化</h3>
<p>这里主要参考龙书学习.这种方法的基本思路,
在于将一个基本块的转化为一个DAG.其实这种方法和上面提到的局部值编号方法本质上是相同的,
只不过形式上略有差别.其实上面的方法中主要针对的是<strong>局部公共子表达式</strong>的问题.</p>
<h4 id="寻找局部公共子表达式">寻找局部公共子表达式</h4>
<p>这里的局部公共子表达式也就是上面所说的冗余的表达式,
只不过是不同教材中的不同表达方式罢了.</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2029%2011%2025%2010%201672284310%201672284310778%20kk9029%20image-20221229112510693%20.png"></p>
<p>其中情况如上.书中还提到了一种情况就是非冗余表达式,
但其值可以确定完全一样的情况,
这种情况需要借助<strong>DAG中的代数恒等式</strong>来确定.</p>
<blockquote>
<p>对于一个块的输出节点, 也就是需要被后续的块所引用的变量,
我们称之为出口处活跃. 这需要借助数据流分析来完成.</p>
</blockquote>
<h4 id="消除死代码">消除死代码</h4>
<p>基于DAG删除死代码的操作可以以如下的方式实现,
从DAG上删除所有没有附加活跃变量的跟节点.重复,直到没有可以删除的为止.也就是说,
在生成的DAG中, 如果一个节点是跟节点,
并且其对应的变量并没有作为后续block的输入变量(也就是不是活跃变量),
就应该将该结点移除.</p>
<h4 id="代数恒等式">代数恒等式</h4>
<h2 id="数据流分析基础">2. 数据流分析基础</h2>
<p><strong>数据流分析</strong>会遍历流图,
收集运行时可能发生的有关信息.之后往往需要根据分析结果采用某种方法调整IR,
从而达到优化的目的.流图是一种以基本块为节点的图, 其中在数据流分析中,
所采用的单位(也就是书中所说的<strong>程序点</strong>)指的是相邻指令语句之间的间隔,
我们根据需要采集的信息抽象出整个程序的状态,
关于这些状态的值在程序点流动时的变化过程是数据流分析中最关注的.</p>
<p>在各种程序点中的, 一个基本块内部相邻的程序点之间没有发生信息的变化,
也就是语句n执行完和语句n+1执行前是一致的,
如果是跨越了基本块的相邻程序点也是这样的.所谓执行路径就是流图中程序点的连续序列.</p>
<p>如果要举例子的话, 如下所示:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2017%2030%2044%201672392644%201672392644690%209F73ol%20image-20221230173044558%20.png" alt="image-20221230173044558" style="zoom:33%;"></p>
<p>由此图可知, 一个程序的路径可以不只一条.</p>
<p>既然上面就提到了,
数据流分析是需要收集信息并且分析信息在流动时的变化情况的,
关于这些“信息”.在这里为了更准确地描述,
对每个语句s的前后的数据流志极为IN[s]和OUT[s].并且定义传递函数, 即OUT[s]
= fs(IN[s]).关于控制流约束就如同上面所说的:</p>
<p>​
<img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2017%2040%2048%201672393248%201672393248399%20kg4JtF%20image-20221230174048309%20.png" alt="image-20221230174048309" style="zoom: 50%;"></p>
<p>此外对于基本块也有这种定义IN[B]和OUT[B].</p>
<h3 id="到达-定值分析">1) 到达-定值分析</h3>
<p>在经过一个程序点时, 一个变量有可能被赋值(改变值,即为定值).</p>
<p>定值分析问题就是分析在给定的d和p点之间对于某个变量x是否发生定值,
如果发生定值就称该变量被kill.</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2017%2052%2023%201672393943%201672393943096%20uC3P7m%20image-20221230175222999%20.png" alt="image-20221230175222999" style="zoom:50%;"></p>
<p>其中gen表示的是某个块中的定值,
kill表示的是后续会将block中的定值kill的定值.关于传递方程,这里是一种“生成-杀死”形式的传递函数,
如下这种形式:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2020%2032%2051%201672403571%201672403571596%20ac9zE3%20image-20221230203251499%20.png" alt="image-20221230203251499" style="zoom:50%;"></p>
<p>之后可以推导出相关的算法.该算法已经给定了<strong>流图中每个基本块B的kill集和gen集,要求我们求出每个基本块的入口点和出口点的定值的集合,
也就是IN[B]和OUT[B].</strong></p>
<p>该算法有伪代码描述如下:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2020%2038%2011%201672403891%201672403891210%20KVvooS%20image-20221230203811120%20.png" alt="image-20221230203811120" style="zoom:50%;"></p>
<h3 id="活跃分析">2) 活跃分析</h3>
<p>活跃分析用于<strong>想要知道某个变量x和程序点p,
x在点p上是否会在流图中的某条从p出发的点中使用</strong>.如果是则称为活跃的,
其中有关的应用是<strong>寄存器分配</strong>,
因为当一个变量被存放到寄存器中后,
我们需要通过这个变量在后面是否活跃从而确定是否可以使用该寄存器.</p>
<p>这里仍然是采用IN、OUT的方式,
不过在这里定义的是一个<strong>表示变量是否活跃的BitSet.</strong>具体的相关集合指的是use和def.前者指的是某一个变量被使用,
后者指的是某一个变量被定值.</p>
<p>输入指的是一个已经计算出use和def的流图,因此相关算法如下:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2020%2048%2025%201672404505%201672404505596%20RVd5PB%20image-20221230204825499%20.png" alt="image-20221230204825499" style="zoom:50%;"></p>
<p>要求输出是一个IN[B]和OUT[B].</p>
<h3 id="可用表达式分析">3) 可用表达式分析</h3>
<p>这里提到的可用表达式也就是前面所提到的冗余表达式,
也就是对于相同形式的表达式, 其结果有没有发生改变, 如果仍然没变,
就可以复用之前的结果.至于判断是否可用的方式, 则是从入口点到p,
如果在此期间x或者y发生了定值, 因此可以说杀死了这个表达式.</p>
<p><strong>相比到达-定值问题中所提到的杀死或者生成,
这里所针对的对象不再是变量而是表达式.</strong>其用途在于寻找全局公共子表达式.
在解决该问题的算法中, 涉及到的抽象有gen和kill,
前者表示生成的表达式的集合,
后者表示被B所杀死的表达式的集合.相关的算法的伪代码描述如下:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2020%2059%2052%201672405192%201672405192418%20nxm03a%20image-20221230205952326%20.png"></p>
<p>对于以上三种问题,
采用了类似的模式去抽象、定义.彼此之间的不同点如下:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2030%2020%2051%2018%201672404678%201672404678809%20Qc2ql6%20image-20221230205118710%20.png" alt="image-20221230205118710" style="zoom:50%;"></p>
<h2 id="静态单赋值形式">3. 静态单赋值形式</h2>
<p><strong>静态单赋值是一种中间表示形式, 保证每个变量只会被赋值一次,
在使用某个变量前一定被定义了.</strong> 在原始的IR中,
一个变量可以分割成多个不同的版本, 每个定义对应了一个版本,
每个版本附带上不同的下标保证新的变量名没有任何重名的.,举个简单的例子:</p>
<pre class="line-numbers language-none"><code class="language-none"># 非SSA代码
y := 1
y := 2
x := y
# SSA代码
y1 := 1
y2 := 2
x1 := y2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实从非SSA中可以看出, y的赋值操作是完全没有必要的.
因此可以体现出一些优化的潜能.SSA所涉及到的优化算法有:常数传播、值域传播、稀疏有条件的常数传播、消除无用代码等等.</p>
<p>对于静态单赋值形式有一个主要问题,在于对于分支, 如下代码:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> x1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword keyword-else">else</span> x2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
x3 <span class="token operator">=</span> <span class="token function">Phi</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其结果要么是来源于x1, 要么是来源于x2,
该函数表示将两者合并起来的结果.如下所示:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2011%2017%2040%201672456660%201672456660312%204CyVo9%20image-20221231111740233%20.png" alt="image-20221231111740233" style="zoom:50%;"></p>
<p>其实还可以进一步化简, 将其中的x2那一行删除.还有一个例子如下:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2011%2024%2041%201672457081%201672457081075%20yW6KuC%20image-20221231112440999%20.png" alt="image-20221231112440999" style="zoom: 33%;"></p>
<p>这一部分的算法简而言之可以分为三步:</p>
<ul>
<li>找出内含变量定制的基础块, 及其<strong>支配边界</strong>.</li>
<li><strong>插入Phi结点</strong>.需要插入在控制流图的汇聚点处,
只要在汇聚点之前的分支中出现了对某个变量的修改,
就需要在该汇聚点插入针对该变量的Phi结点,
Phi结点的操作数是分支路径中重新定义的变量.</li>
<li>变量重命名.</li>
</ul>
<p>接下来详细地说明<strong>插入Phi结点和变量重命名的算法</strong>.</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2011%2038%2024%201672457904%201672457904741%2032rQjt%20image-20221231113824658%20.png" alt="image-20221231113824658" style="zoom:50%;"></p>
<h2 id="循环优化">4. 循环优化</h2>
<p>关于循环在数据流图中的准确定义: 是一系列(S)数据流图中的节点,
其中包含一个header节点, 遵循如下几种性质:</p>
<ul>
<li>某个(些)节点中有节点指向header节点.</li>
<li>header也有一个指向其他节点的路径.</li>
<li>外部的其他节点只能通过heder进入S.</li>
</ul>
<h3 id="必经结点">1) 必经结点</h3>
<p>我们的首要任务是找到循环,
其中<strong>必经结点</strong>的概念非常有用.这个概念很好理解,
就和它的字面意思一样.必经结点在某些教材中也被称为<strong>支配结点</strong>.</p>
<h4 id="寻找必经结点的算法">寻找必经结点的算法</h4>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2012%2051%2035%201672462295%201672462295336%201sj5eg%20image-20221231125135249%20.png" alt="image-20221231125135249" style="zoom: 33%;"></p>
<p>对于给定的一个点n, 其中有p1, p2.....作为其前驱节点,
D[i]表示的是i的必经结点的集合.在进行计算时可以通过类似于拓扑排序或者dfs的模式进行递归求解.</p>
<h4 id="直接必经结点">直接必经结点</h4>
<p><strong>定理: 如果d、e都是n的必经结点, 要么是d为e的必经结点,
要么e是d的必经结点</strong>.</p>
<p>直接必经结点(idom)的性质如下:</p>
<ul>
<li>idom(n) != n</li>
<li>是n的必经结点.</li>
<li>不是其他必经结点的必经结点.</li>
</ul>
<blockquote>
<p>除了S0外, 所有其他结点都至少有一个除自己之外的必经结点, 因此除了S0外,
所有其他结点都恰好有一个直接必经结点.可以将概念理解成距离结点n最近的必经结点.</p>
</blockquote>
<p>关于必经结点树, 直将每个结点的直接必经结点画出来就好了.</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2012%2057%2044%201672462664%201672462664576%20TLVScl%20image-20221231125744494%20.png" alt="image-20221231125744494" style="zoom:50%;"></p>
<h4 id="循环">循环</h4>
<p><strong>自然循环</strong>: 集合中的任何结点x, 其必经结点都有h,
并且有一个从x到n不包含h的路径.</p>
<blockquote>
<p>最内层循环往往是最值得优化的, 但是对于共享header结点的循环来说,
难以确定哪一个才是最内层循环,
对此的处理方式有将这些同一个header的循环合并,
但是合并之后就不一定是自然循环了.</p>
</blockquote>
<p><strong>嵌套循环</strong>: A和B是两个循环体,两者不共享header结点,
但是b(B的header结点)在A中,那么B结点也就是A结点的<strong>真子集</strong>.B就是A的内循环.</p>
<p>一个循环嵌套树如下所示:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2013%2018%2030%201672463910%201672463910249%20AIYzU3%20image-20221231131830163%20.png" alt="image-20221231131830163" style="zoom:50%;"></p>
<h4 id="循环前置结点">循环前置结点</h4>
<p>很多循环优化都需要将一些语句插入到即将进入到循环体之前要执行的位置.比如说循环不变量外提.因此需要一个<strong>循环前置结点</strong>.</p>
<p>加入循环前置结点之后, 循环内到header的结点仍然指向header,
但是循环外部的结点指向header的路径都被重定向到了header.</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2013%2031%2011%201672464671%201672464671033%20mKszue%20image-20221231133110940%20.png" alt="image-20221231133110940" style="zoom: 50%;"></p>
<h3 id="循环不变量计算">2) 循环不变量计算</h3>
<p>首先需要确定的是, 对于一个d: t &lt;- a1 op
a2是否是循环不变量的条件(满足其中之一即可)是:</p>
<ul>
<li>a1和a2都是常数.</li>
<li>所有到达的d的ai定值都在循环之外.</li>
<li>a1和a2中只有一个定值到达d, 并且该定值是循环不变量.</li>
</ul>
<p>其中简要说明其方法为:</p>
<ul>
<li>找出所有操作数是常数或者循环外定值的语句.</li>
<li>重复地寻找其操作数都为循环不变量的定值.</li>
</ul>
<p>确定循环不变量之后,
需要考虑的是外提.然而外提又是结果不会正确.比如说下面的这几个例子:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2013%2043%2007%201672465387%201672465387355%20GrPwX3%20image-20221231134307261%20.png" alt="image-20221231134307261" style="zoom:50%;"></p>
<p>因此考虑还增加一些限制条件:</p>
<ul>
<li>d是所有该循环出口结点的必经结点: 也就是说t在循环出口结点,
t是活跃的.</li>
<li>在循环体中t只有一个定值.</li>
<li>t不属于循环前置结点的出口活跃集合.</li>
</ul>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2022%2012%2031%2013%2049%2003%201672465743%201672465743789%20U0yAnZ%20image-20221231134903709%20.png" alt="image-20221231134903709" style="zoom:50%;"></p>
<h2 id="部分冗余消除">5. 部分冗余消除</h2>
<p>这种优化的目的在于<strong>尽量减少表达式求值的次数</strong>.比如说可以通过移动x+y这种表达式的求值的位置,
在必要时将求值结果保存在临时变量中.由于需要寻找适当的位置对表达式进行求值,
因此需要借助数据流分析技术.</p>
<p>关于对部分冗余的理解,
指的是冗余只存在于部分路径而非全部路径中(<strong>其实之前学到的公共子表达式和循环不变代码移动都是其中的特例</strong>).</p>
<h4 id="懒惰代码移动问题">懒惰代码移动问题</h4>
<p>我们所期望的部分冗余消除算法优化应该能达到以下的目的:</p>
<ul>
<li>所有不复制代码就可以消除的表达式冗余计算都被消除了.</li>
<li>优化之后的程序不会执行原本不执行的计算.</li>
<li><strong>尽可能将表达式的计算时刻延后</strong>(声明周期往往缩短,
涉及到的路径减少).</li>
</ul>
<p>懒惰代码移动就是以第三点为目的的优化方式.</p>
<h2 id="寄存器分配与指派">6. 寄存器分配与指派</h2>
<p>在生成的IR代码中, 其中假定有无限数量的寄存器.
<strong>寄存器分配的任务在于将大量的临时变量分配到符合目标机器的有限的寄存器之中.</strong>其前提往往需要使用到通过数据流分析所得来的冲突图,
在冲突图中, 每个结点代表了IR中的一个临时变量,
存在边的一对结点表示的是不能分配同一个寄存器的变量.</p>
<p>如果想要通过冲突图找出一个寄存器分配方案, 需要做的就是运行图着色算法,
追求尽可能少的颜色, 并且存在边的结点之间不可以使用相同的颜色.</p>
<h3 id="基本概念">1) 基本概念</h3>
<p>图着色算法本身是一个NP完全问题,
但在实际开发中可以通过一种线性时间的方法.其过程分为四步骤:</p>
<ul>
<li><strong>通过数据流分析构造冲突图.</strong>需要借助活跃分析(确切地说是live
range, 对于live range发生重叠的变量来说, 需要在冲突图中构造出边).</li>
<li><strong>简化启发式地对图着色</strong>:
<ul>
<li>假设图G有一个结点m, 其邻居点数少于K, K是机器寄存器的个数.</li>
<li>设G‘为从G中去除了m的子图, 如果G’可以用K色着色,
那么G也可以.(因为m的邻居少于K, 这些邻居最多用K-1种颜色).</li>
<li>简而言之, <strong>重复地删除度数少于K的结点(将其入栈),
每减少掉一个同时也就减少了其他节点的度数</strong>.</li>
</ul></li>
<li><strong>对于某一个度数大于等于K的结点,
需要考虑溢出</strong>.此时考虑在图中选择一个结点, 将其放在内存中,
不再对其分配寄存器,同时也将其入栈.</li>
<li><strong>将颜色指派给图中的结点</strong>. 此时冲突图是一个空的状态,
这时将栈顶的结点不断地加入到原图中, 每加一个结点就对其着色.</li>
</ul>
<p>总体来说, 这里需要区分简化版:<strong>每次只是选择度数&lt;n的结点,
将其从图中移除后入栈, 迭代直到图为空为止</strong>.之后分配颜色,
从栈中逐个弹出, 插入图中原本的位置, 并同时分配颜色, 直到栈空.</p>
<h3 id="合并">2) 合并</h3>
<p><strong>如果在冲突图中,
一个传送(内存move)指令的源操作数和目的操作数对应的结点不存在边,
可以删除该传送指令, 可以合并成新的结点</strong>.</p>
<p>但是由于合并两个结点之后, 导致冲突图发生变化,
因此可能导致原本可K着色的图成了不可着色的, 如何应对这种问题呢,
需要为可合并结点增加额外的条件:</p>
<ul>
<li>Briggs: 如果合并后的结点仍然度数少于K, 那么可以合并.</li>
<li>George:</li>
</ul>
<p>因此考虑了合并之后的图着色算法流程如下:</p>
<figure>
<img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2004%2023%2012%2007%201672845127%201672845127423%20nyNhVu%20image-20230104231207297%20.png" alt="image-20230104231207297">
<figcaption aria-hidden="true">image-20230104231207297</figcaption>
</figure>
<p>这里总结一下带有合并的图着色算法:</p>
<ul>
<li><strong>构造</strong>, 将结点分为传送有关和传送无关的.</li>
<li><strong>简化</strong>, 每次将低于K度数的结点移除,并入栈.</li>
<li><strong>合并</strong>, 对简化图进行合并.</li>
<li><strong>冻结</strong>, 如果简化和合并都不能进行,
寻找一个度数较低的传送相关的结点, 冻结该指令所关联的传输指令.</li>
<li><strong>移除</strong>, 如果没有低度数结点,
选择一个可能移除的高度数结点并将其压栈.</li>
<li><strong>选择</strong>, 弹出栈, 同时指派颜色.</li>
</ul>
<h3 id="预着色的结点">3) 预着色的结点</h3>
<p><strong>机器寄存器是需要进行预着色的</strong>.</p>
<h3 id="图着色相关实现">4) 图着色相关实现</h3>
<p>虎书中中对于对于冲突图的实现建议是, 同时使用邻接表和临接矩阵实现,
因为前者对于获取某结点的所有相邻结点比较方便,
而后者对于判断某两个结点(比如说X和Y)是否相邻比较方便.</p>
<p>虎书中给出一个递归的伪代码:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2004%2022%2039%2016%201672843156%201672843156548%20Z56hDO%20image-20230104223916416%20.png" style="zoom: 50%;"></p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2004%2022%2039%2049%201672843189%201672843189846%20Qns06s%20image-20230104223949762%20.png" alt="image-20230104223949762" style="zoom:50%;"></p>
<h2 id="reference">Reference</h2>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/70299120">编译工程9：中间代码生成</a></p>
<p><a target="_blank" rel="noopener" href="https://kiprey.github.io/2020/06/LLVM-IR-pass/#5-数据流分析">代码优化与LLVM
IR pass</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/178228779">编译器算法之寄存器分配</a></p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#llvm%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">0. LLVM基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">1) 系统总览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#llvm-program-structure"><span class="toc-number">1.2.</span> <span class="toc-text">2) LLVM Program Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#more-on-the-llvm-compiler"><span class="toc-number">1.3.</span> <span class="toc-text">3) More on the LLVM Compiler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#data-structures"><span class="toc-number">1.3.1.</span> <span class="toc-text">Data Structures</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class-hierarchy"><span class="toc-number">1.3.2.</span> <span class="toc-text">Class Hierarchy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#casting-and-type-introspection"><span class="toc-number">1.3.3.</span> <span class="toc-text">Casting and Type
Introspection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iterators"><span class="toc-number">1.3.4.</span> <span class="toc-text">Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#visitor-pattern"><span class="toc-number">1.3.5.</span> <span class="toc-text">Visitor Pattern</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E4%BC%98%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">1. 局部优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#value-numbering"><span class="toc-number">2.1.</span> <span class="toc-text">1) Value Numbering</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95lvm%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">拓展LVM算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Edag%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text">2) 基于DAG的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%B1%80%E9%83%A8%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">寻找局部公共子表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E6%AD%BB%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">消除死代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E6%95%B0%E6%81%92%E7%AD%89%E5%BC%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">代数恒等式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">2. 数据流分析基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B0%E8%BE%BE-%E5%AE%9A%E5%80%BC%E5%88%86%E6%9E%90"><span class="toc-number">3.1.</span> <span class="toc-text">1) 到达-定值分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E8%B7%83%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">2) 活跃分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">3) 可用表达式分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">3. 静态单赋值形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">4. 循环优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%85%E7%BB%8F%E7%BB%93%E7%82%B9"><span class="toc-number">5.1.</span> <span class="toc-text">1) 必经结点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%BF%85%E7%BB%8F%E7%BB%93%E7%82%B9%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">寻找必经结点的算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%BF%85%E7%BB%8F%E7%BB%93%E7%82%B9"><span class="toc-number">5.1.2.</span> <span class="toc-text">直接必经结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.1.3.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%89%8D%E7%BD%AE%E7%BB%93%E7%82%B9"><span class="toc-number">5.1.4.</span> <span class="toc-text">循环前置结点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E9%87%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">5.2.</span> <span class="toc-text">2) 循环不变量计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E5%86%97%E4%BD%99%E6%B6%88%E9%99%A4"><span class="toc-number">6.</span> <span class="toc-text">5. 部分冗余消除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%83%B0%E4%BB%A3%E7%A0%81%E7%A7%BB%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-number">6.0.1.</span> <span class="toc-text">懒惰代码移动问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%E4%B8%8E%E6%8C%87%E6%B4%BE"><span class="toc-number">7.</span> <span class="toc-text">6. 寄存器分配与指派</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">1) 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6"><span class="toc-number">7.2.</span> <span class="toc-text">2) 合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E7%9D%80%E8%89%B2%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-number">7.3.</span> <span class="toc-text">3) 预着色的结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9D%80%E8%89%B2%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.4.</span> <span class="toc-text">4) 图着色相关实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference"><span class="toc-number">8.</span> <span class="toc-text">Reference</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/122854432.html"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/122854432.html&text=编译器后端以及优化相关的基础理论"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/122854432.html&title=编译器后端以及优化相关的基础理论"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/122854432.html&is_video=false&description=编译器后端以及优化相关的基础理论"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=编译器后端以及优化相关的基础理论&body=Check out this article: http://example.com/2022/122854432.html"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/122854432.html&title=编译器后端以及优化相关的基础理论"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/122854432.html&title=编译器后端以及优化相关的基础理论"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/122854432.html&title=编译器后端以及优化相关的基础理论"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/122854432.html&title=编译器后端以及优化相关的基础理论"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/122854432.html&name=编译器后端以及优化相关的基础理论&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/122854432.html&t=编译器后端以及优化相关的基础理论"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    yfs
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
      --><li><a href="/">首页</a></li><!--
    --><!--
      --><li><a href="/about/">关于</a></li><!--
    --><!--
      --><li><a href="/archives/">归档</a></li><!--
    -->
      </ul>
      <ul>
        
          <!-- 不蒜子统计 -->
          <span id="busuanzi_container_site_pv">
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
          </span>
          <span class="post-meta-divider">|</span>
          <span id="busuanzi_container_site_uv" style='display:none'>
                  本站访客数<span id="busuanzi_value_site_uv"></span>人
          </span>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        
      </ul>
    </nav>
  </div>
  
</footer>

<script src="/js/prism/prism.js" async></script>


    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'cactus-1';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'owner/githubrepo';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>
