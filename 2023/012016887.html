<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="TinyMuduo这个项目可以说是在理解并模仿陈硕的muduo的基础上所作,我在上个学期其实就想要着手去做这件事,不过中间因为种种原因搁浅了,到了寒假有时间了再次拾起,可以说是把之前挖的坑给填上了. 关于这个项目的价值,首先我认为muduo中对于Modern C++的应用以及代码风格非常具有借鉴价值,其次可以对系统编程和网络编程有很大的锻炼,尤其是这个过程中需要查阅许多Linux系统调用的资料、以">
<meta property="og:type" content="article">
<meta property="og:title" content="记录一个网络库的核心实现">
<meta property="og:url" content="http://example.com/2023/012016887.html">
<meta property="og:site_name" content="Yfs&#39;s Box">
<meta property="og:description" content="TinyMuduo这个项目可以说是在理解并模仿陈硕的muduo的基础上所作,我在上个学期其实就想要着手去做这件事,不过中间因为种种原因搁浅了,到了寒假有时间了再次拾起,可以说是把之前挖的坑给填上了. 关于这个项目的价值,首先我认为muduo中对于Modern C++的应用以及代码风格非常具有借鉴价值,其次可以对系统编程和网络编程有很大的锻炼,尤其是这个过程中需要查阅许多Linux系统调用的资料、以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2021%2009%2035%2017%201674264917%201674264917961%20Ij68cW%20image-20230121093517832%20.png">
<meta property="article:published_time" content="2023-01-20T01:27:28.000Z">
<meta property="article:modified_time" content="2023-01-22T04:25:46.060Z">
<meta property="article:author" content="yfs">
<meta property="article:tag" content="系统编程">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2021%2009%2035%2017%201674264917%201674264917961%20Ij68cW%20image-20230121093517832%20.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>记录一个网络库的核心实现</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<link rel="stylesheet" href="/js/prism/prism.css">

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/012241324.html"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/011947300.html"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/012016887.html"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/012016887.html&text=记录一个网络库的核心实现"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/012016887.html&title=记录一个网络库的核心实现"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/012016887.html&is_video=false&description=记录一个网络库的核心实现"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=记录一个网络库的核心实现&body=Check out this article: http://example.com/2023/012016887.html"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/012016887.html&title=记录一个网络库的核心实现"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/012016887.html&title=记录一个网络库的核心实现"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/012016887.html&title=记录一个网络库的核心实现"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/012016887.html&title=记录一个网络库的核心实现"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/012016887.html&name=记录一个网络库的核心实现&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/012016887.html&t=记录一个网络库的核心实现"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">1. 总体架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-number">2.</span> <span class="toc-text">2. 核心模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socketchannel"><span class="toc-number">2.1.</span> <span class="toc-text">1).Socket、Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epollereventloop"><span class="toc-number">2.2.</span> <span class="toc-text">2).Epoller、EventLoop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#acceptortcpconnectiontcpserver"><span class="toc-number">2.3.</span> <span class="toc-text">3).Acceptor、TcpConnection、TcpServer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E9%AA%8C%E4%B8%8E%E6%80%9D%E8%80%83"><span class="toc-number">3.</span> <span class="toc-text">3. 经验与思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#one-loop-per-thread%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">3.1.</span> <span class="toc-text">1) one loop per
thread和线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87stdfunctionstdbind%E6%9D%A5%E6%9B%BF%E4%BB%A3%E5%A4%9A%E6%80%81"><span class="toc-number">3.2.</span> <span class="toc-text">2)
通过std::function+std::bind来替代多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onmessage%E5%9B%9E%E8%B0%83%E5%B0%91%E7%94%A8%E6%A0%88%E4%B8%8A%E4%B8%8D%E5%AE%9A%E9%95%BFbuffer"><span class="toc-number">3.3.</span> <span class="toc-text">3)
onMessage回调少用栈上不定长buffer</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        记录一个网络库的核心实现
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">yfs</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-01-20T01:27:28.000Z" itemprop="datePublished">2023-01-20</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/C/" rel="tag">C++</a>, <a class="tag-link-link" href="/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" rel="tag">系统编程</a>, <a class="tag-link-link" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">网络编程</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>TinyMuduo这个项目可以说是在理解并模仿陈硕的muduo的基础上所作,我在上个学期其实就想要着手去做这件事,不过中间因为种种原因搁浅了,到了寒假有时间了再次拾起,可以说是把之前挖的坑给填上了.</p>
<p>关于这个项目的价值,首先我认为muduo中对于Modern
C++的应用以及代码风格非常具有借鉴价值,其次可以对系统编程和网络编程有很大的锻炼,尤其是这个过程中需要查阅许多Linux系统调用的资料、以及多线程的一些东西,并且代码量也挺大,仅仅是我实现的这个Tiny版的,其核心库就有3k行左右的代码量,算上example和test大概都有将近5k行代码,虽然算不上是原创,但是自己一点一点地码出来并且进行debug,颇耗费时间.</p>
<p>在这篇博客之中,我会首先介绍其总体架构,然后就其中的某些核心模块进行说明,最后写一些我从中学习到的一些经验性的东西.</p>
<h2 id="总体架构">1. 总体架构</h2>
<p>首先需要介绍的是,什么是reactor模式.reactor模式中,会有一个(或者多个)事件监听分发器,可以通过将特定的文件描述符和事件类型及其回调注册到事件监听器上,之后一旦某些被注册的相关事件触发,就会执行相应的回调.使用这种模式最大的优点在于,无需主动等待某个文件描述符的事件触发(避免了因为等待某个文件描述符的事件而阻塞了其他的文件描述符).结合网络编程的话,这些事件往往就有一个listen的fd的可读事件(往往是新连接建立)、一个tcp连接对应的fd上的可读事件(连接上有新数据到来)等等.</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2021%2009%2035%2017%201674264917%201674264917961%20Ij68cW%20image-20230121093517832%20.png" alt="image-20230121093517832" style="zoom: 33%;"></p>
<h2 id="核心模块">2. 核心模块</h2>
<h3 id="socketchannel">1).Socket、Channel</h3>
<p>Socket和Channel这两部分可以说是系统中最最基础的组件,<strong>前者封装了一个打开了的非阻塞文件描述符,后者描述了一个文件描述符在注册到reactor时所需要的属性和方法</strong>.两者组合绑定到一起,描述了一个“会被注册到reactor的非阻塞文件描述符”,这么一种对象.</p>
<p>至于Socket的实现中的一些细节,没有太多可说的,其车成员函数大概是对listen、accept、bind等系统调用做一层浅浅的封装.其中<strong>运用了RAII保证对Socket(文件描述符)的自动关闭</strong>,其析构函数如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">Socket</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token double-colon punctuation">::</span><span class="token function">close</span><span class="token punctuation">(</span>fd_<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>关于Channel的实现则要复杂得多,这一部分首先要考虑的是,如果是基于Epoll的事件监听器,都需要哪些属性?</p>
<ul>
<li>要被注册到Epoll中的文件描述符.</li>
<li>Interest Event的类型.</li>
<li>返回Event类型及其相关回调.</li>
</ul>
<p>因此其数据成员如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        <span class="token keyword keyword-bool">bool</span> in_loop_<span class="token punctuation">;</span>      <span class="token comment">// 是否已经加入到loop中</span>
        ChannelState state_<span class="token punctuation">;</span>			<span class="token comment">// 被注册到Epoll中,该Channel对应的fd所处的状态.</span>
        EventLoop <span class="token operator">*</span>owner_loop_<span class="token punctuation">;</span>		<span class="token comment">// 所归属的循环体</span>
        <span class="token keyword keyword-uint32_t">uint32_t</span> event_<span class="token punctuation">;</span>    <span class="token comment">// Interested Event</span>
        <span class="token keyword keyword-uint32_t">uint32_t</span> revent_<span class="token punctuation">;</span> <span class="token comment">// 从epoll_wait中返回的事件</span>
        <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> fd_<span class="token punctuation">;</span>    <span class="token comment">// 需要被监听事件的文件描述符</span>
        std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">&gt;</span> tie_<span class="token punctuation">;</span>
        <span class="token keyword keyword-bool">bool</span> tied_<span class="token punctuation">;</span>
<span class="token comment">// read、write、close、error等类型事件的回调函数</span>
        CallBackFunc read_callback_<span class="token punctuation">;</span>
        CallBackFunc write_callback_<span class="token punctuation">;</span>
        CallBackFunc close_callback_<span class="token punctuation">;</span>
        CallBackFunc error_callback_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中相关的api主要是对于event、revent等字段的修改和返回等操作.之所以需要一个EventLoop指针,是因为每个Channel都归属于一个EventLoop(因为每个EventLoop中都会有一个惟一Epoller),可以说每个Channel都需要借助EventLoop访问其所归属的Epoller,才可以进行<code>EPOLL_CTL_ADD</code>,<code>EPOLL_CTL_MOD</code>等等,这些操作正是当一个Channel中对应的interested
event更新时所需要进行的.因此在Channel中也就有一个update函数,其实现如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     owner_loop_<span class="token operator">-&gt;</span><span class="token function">updateChannel</span><span class="token punctuation">(</span><span class="token keyword keyword-this">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token class-name">EventLoop</span><span class="token double-colon punctuation">::</span><span class="token function">updateChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    epoller_<span class="token operator">-&gt;</span><span class="token function">updateChannel</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在epoller中的updateChannel会根据当前fd在epoller的状态(也就是Channel中的state字段)去判断所需要执行的更新操作,究竟是EPOLL_CTL_ADD、EPOLL_CTL_MOD还是EPOLL_CTL_DEL.这个将会在后面细说.至于update什么时候需要调用,那就是<strong>当Channel中所对应的文件描述符的event(Interested
event)发生改变的时候.</strong>比如说:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">setReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      event_ <span class="token operator">|=</span> READ_EVENT<span class="token punctuation">;</span>
      <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token function">setWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      event_ <span class="token operator">|=</span> WRITE_EVENT<span class="token punctuation">;</span>
      <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每个Channel中还有一个handleEvent方法,该方法起到一个分发器的作用,在Reactor的Epoller中,等到epoll_wait返回到某些事件时,将其中的每个Channel的revet都设置好,然后会从中遍历每个Channel调用的handleEvent方法,在该方法中,会通过检查revent的事件类型,调用相应的回调,具体逻辑如下所示:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>revent_ <span class="token operator">&amp;</span> READ_EVENT<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 可读事件</span>
   <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>read_callback_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">read_callback_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>revent_ <span class="token operator">&amp;</span> WRITE_EVENT<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 可写事件</span>
   <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>write_callback_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">write_callback_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>revent_ <span class="token operator">&amp;</span> EPOLLERR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>error_callback_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">error_callback_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>revent_ <span class="token operator">&amp;</span> EPOLLHUP<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>revent_ <span class="token operator">&amp;</span> EPOLLIN<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>close_callback_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">close_callback_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后,简要地说明一下Socket和Channel之间的关系,在一个基于事件驱动的网络库中,两者往往不是独立存在使用的,通常组合在一起,描述一个“会被注册到reactor并监听的非阻塞文件描述符”,比如说后面的Acceptor、TcpConnection,因此两者的生命周期往往也是“同生共死”的.</p>
<h3 id="epollereventloop">2).Epoller、EventLoop</h3>
<p>Epoller是实现事件监听与分发的核心对象,其核心是linux
epoll,这是一种常用的IO复用技术.其工作模式相当于epoller维护了一个个文件描述符的interest
events,当其中某个(某些)文件描述符的interest
event触发的时候,epoller就可以返回这些事件,接着就可以对这些事件一一进行相应处理.</p>
<p>其中重要的API,有epoll_create,用于创建一个“事件监听器”,返回的是一个文件描述符,因此对于这种对象也是通过文件描述符来进行管理的(<strong>因此其析构函数和Socket一样,都对该文件描述符进行close</strong>),还有epoll_wait,阻塞地等待interest
events中有事件触发并返回,返回值为触发的interest
event的数量,<strong>一般搭配while循环,以一种类似于轮询的方式运行</strong>.epoll_ctl则有ADD、MOD、DEL等操作类型,分别与文件描述符的注册、修改interest
event类型、移除有关.</p>
<p>由于Epoller通常是放置一个循环体中,每一轮通过epoll_wait工作,
在该网络库中,EventLoop正是对这样“运行着Epoller的循环体”所进行的封装,<strong>因此对于两者的关系,我们可以说一个EventLoop是一个Epoller的归属者</strong>.</p>
<p>在EventLoop中的核心函数如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">updateChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">removeChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">runInLoop</span><span class="token punctuation">(</span>QueuedFunctor func<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>loop用来运行循环体,也就是启动该EventLoop进行工作.runInLoop被外部调用,将一些需要执行的任务加入到EventLoop的任务队列中,运行.updateChannel、removeChannel是对Epoller中updateChannel、removeChannel的一层wrapper.</p>
<p>EventLoop的核心数据成员如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    <span class="token keyword keyword-const">const</span> pid_t thread_id_<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>mutex mutex_<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Epoller<span class="token operator">&gt;</span> epoller_<span class="token punctuation">;</span>  <span class="token comment">// 一个EventLoop是一个Epoller的所有者</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>TimerQueue<span class="token operator">&gt;</span> timer_queue_<span class="token punctuation">;</span>
<span class="token comment">// 用于唤醒正在因为epoll_wait所导致的休眠</span>
    <span class="token keyword keyword-int">int</span> wakeup_fd_<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Channel<span class="token operator">&gt;</span> wakeup_channel_<span class="token punctuation">;</span>
    ChannelVector active_channels_<span class="token punctuation">;</span>     <span class="token comment">// 用于存放从poll中所返回的channels</span>
    std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span>QueuedFunctor<span class="token operator">&gt;</span> queued_list_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><strong>为什么需要一个wake_fd_及其Channel?</strong></p>
<p>对于一个runInLoop的任务来说,不希望该任务会因为epoll_wait的阻塞导致迟迟没有运行.因此需要一个wakeup_fd将其唤醒.wakeup_fd就像其他文件描述符及其Channel一样在EventLoop被初始化时注册,并设置为可读.当执行wakeup函数时,实质上是对该文件描述符进行write,因此会触发可读事件,EventLoop就从epoll_wait的休眠中苏醒过来了.</p>
</blockquote>
<p>loop方法的实现逻辑如下,也描述了一个事件循环的工作模式:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">EventLoop</span><span class="token double-colon punctuation">::</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    is_looping_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    is_quit_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_quit_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        active_channels_<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-auto">auto</span> return_time <span class="token operator">=</span> epoller_<span class="token operator">-&gt;</span><span class="token function">epoll</span><span class="token punctuation">(</span>defaultTimeoutMs<span class="token punctuation">,</span> active_channels_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> channel <span class="token operator">:</span> active_channels_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            channel<span class="token operator">-&gt;</span><span class="token function">handleEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 处理返回的事件</span>
        <span class="token punctuation">}</span>
        <span class="token function">doQueuedFunctors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    is_looping_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>简而言之,首先调用Epoller中的epoll方法(实际上就是对epoll_wait的封装,当从epoll_wait返回之后,将结果填充到active_channels_,还包括对返回事件类型的设置).之后遍历<code>active_channels_</code>,分别调用其中的事件回调,处理事件.最后将外部加入到任务运行,这就是一轮循环中所做的事情.</p>
<p>上面所涉及到的Epoller中关于epoll方法的实现细节如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TimeStamp <span class="token class-name">Epoller</span><span class="token double-colon punctuation">::</span><span class="token function">epoll</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> timeout_second<span class="token punctuation">,</span> ChannelVector <span class="token operator">&amp;</span>channel_list<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword keyword-auto">auto</span> timeout_millsecond <span class="token operator">=</span> timeout_second<span class="token punctuation">;</span>        <span class="token comment">// epoll中的单位是mill second，要先转化一下</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>timeout_millsecond <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        timeout_millsecond <span class="token operator">=</span> timeout_second <span class="token operator">*</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>TimeStamp<span class="token double-colon punctuation">::</span>MillSecondsPerSecond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>           <span class="token comment">// 如果是-1000就会出现反复频繁触发的问题</span>

    <span class="token keyword keyword-uint16_t">uint16_t</span> epoll_cnt <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">epoll_wait</span><span class="token punctuation">(</span>epoller_fd_<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token operator">*</span>events_<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                 <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>events_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> timeout_millsecond<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// max_size就是一次读取的最大事件数</span>
    TimeStamp now_time <span class="token operator">=</span> <span class="token class-name">TimeStamp</span><span class="token double-colon punctuation">::</span><span class="token function">getNowTimeStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    channel_list<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>epoll_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> epoll_cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// 这里有一个地方需要注意, 要用的是epoll_cnt,而不是直接遍历events</span>
        <span class="token comment">// 从中读取指针，其中藏着Channel的指针</span>
        Channel <span class="token operator">*</span>channel <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Channel<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>events_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        channel<span class="token operator">-&gt;</span><span class="token function">setRevent</span><span class="token punctuation">(</span>events_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token punctuation">)</span><span class="token punctuation">;</span>
        channel_list<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将Channel追加进入</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>epoll_cnt <span class="token operator">==</span> events_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 需要扩容,借助vector的可扩容机制</span>
        events_<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> epoll_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> now_time<span class="token punctuation">;</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><strong>借助epoll_event中的data保存Channel指针</strong></p>
<p>epoll_event结构体描述了一个可以被epoll监听的事件,其组成如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">epoll_event</span>
<span class="token punctuation">{</span>
  <span class="token keyword keyword-uint32_t">uint32_t</span> events<span class="token punctuation">;</span>	<span class="token comment">/* Epoll events */</span>
  epoll_data_t data<span class="token punctuation">;</span>	<span class="token comment">/* User data variable */</span>
<span class="token punctuation">}</span> __EPOLL_PACKED<span class="token punctuation">;</span>
<span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-union">union</span> epoll_data
<span class="token punctuation">{</span>
  <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
  <span class="token keyword keyword-int">int</span> fd<span class="token punctuation">;</span>
  <span class="token keyword keyword-uint32_t">uint32_t</span> u32<span class="token punctuation">;</span>
  <span class="token keyword keyword-uint64_t">uint64_t</span> u64<span class="token punctuation">;</span>
<span class="token punctuation">}</span> epoll_data_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中data是一个联合体,用于保存与该event相关的一些数据,其中ptr可以保存任何类型的指针,如果将Channel的指针保存在其中,就可以在epoll_wait返回之后直接通过返回的epoll_event来获取对应的Channel了,无需额外再维护一个fd到Channel的map.</p>
</blockquote>
<p>至于updateChannel函数,其本质上也就是Epoller中的updateChannel,该函数利用了channel对应的文件描述符在Epoller中的具体状态来判断接下来具体的update行为.update最底层是利用了epoll_ctl函数来进行操作,相关代码如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">Epoller</span><span class="token double-colon punctuation">::</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword keyword-int32_t">int32_t</span> op<span class="token punctuation">,</span> Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">epoll_event</span> event<span class="token punctuation">;</span>

    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    event<span class="token punctuation">.</span>events <span class="token operator">=</span> channel<span class="token operator">-&gt;</span><span class="token function">getEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>ptr <span class="token operator">=</span> channel<span class="token punctuation">;</span>

    <span class="token keyword keyword-int">int</span> ret <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epoller_fd_<span class="token punctuation">,</span> op<span class="token punctuation">,</span> channel<span class="token operator">-&gt;</span><span class="token function">getFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span>  <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        LOG_ERROR <span class="token operator">&lt;&lt;</span> <span class="token string">"epoll ctl "</span> <span class="token operator">&lt;&lt;</span> channel<span class="token operator">-&gt;</span><span class="token function">getFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" error, epoller fd is "</span> <span class="token operator">&lt;&lt;</span>
        epoller_fd_ <span class="token operator">&lt;&lt;</span> <span class="token string">", the errorno is "</span> <span class="token operator">&lt;&lt;</span> errno<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>epoll_ctl的参数分别对应了epoller关联的文件描述符、CTL操作类型(MOD、DEL、ADD)等类型、被监听的文件描述符、更新后的epoll_event.</p>
<p>关于Epoller的数据成员如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-uint16_t">uint16_t</span> epoller_fd_<span class="token punctuation">;</span>
EventsVector events_<span class="token punctuation">;</span>
ChannelsMap channels_map_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>分别是Epoller本身的文件描述符,还有用于监听的interest
event的集合,当前所维护的Channel的集合.<strong>这里的Epoller是使用的水平触发</strong>.</p>
<blockquote>
<p><strong>epoll水平触发和边缘触发的区别</strong></p>
<p>水平触发指的是,一旦被监听的文件描述符中的事件处于某种状态(符合interest
event),调用epoll_wait就会一直返回,直到该事件事件被处理,以至于不再处于该状态.边缘触发指的是,只在文件描述符的event类型发生变化的时候返回一次.</p>
<p>水平触发模式的使用对后来对于读写事件的处理产生了重要的影响,在后面结合Buffer以及TcpConnection会细说.</p>
</blockquote>
<h3 id="acceptortcpconnectiontcpserver">3).Acceptor、TcpConnection、TcpServer</h3>
<p>关于Acceptor和TcpConnction,都可以说基于Socket和Channel的组合所构成的对象,前者指的是一个持续listen用来接收连接的文件描述符,后者则是从Acceptor中所accept所得的网络连接.<strong>一个Acceptor,和一个个活跃的TcpConnection构成了一个TcpServer类的核心成分</strong>.</p>
<p>由于这时基于epoll
IO复用的网络库,Acceptor和TcpConnection也需要被加入到Epoller对象及其EventLoop中.在这两个class的设计中,主要考虑的是如何将网络事件和Channel中的Epoll事件结合起来.比如说Acceptor连接到来对应了Channel中的read事件,网路连接的数据到来、数据可写、连接关闭等事件也就对应了Channel中的read、write、close.考虑清楚这些对应关系之后,就需要考虑这些事件所对应的回调了.</p>
<p>关于Acceptor中所涉及的事件回调,最核心的就是readHandle,对于一个listen的描述符来说,读事件就意味着有新的连接到来,对其调用accept就行了,正常情况下再根据返回的文件描述符和地址代入到newconnection_func_中(TcpServer会为其提供的回调),其中的readHandle的实现如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">Acceptor</span><span class="token double-colon punctuation">::</span><span class="token function">handleNewConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    SockAddress peer_addr<span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> accept_fd <span class="token operator">=</span> socket_<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>peer_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>accept_fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EMFILE<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 错误类型对应了文件描述符耗尽的类型</span>
            <span class="token double-colon punctuation">::</span><span class="token function">close</span><span class="token punctuation">(</span>idel_fd_<span class="token punctuation">)</span><span class="token punctuation">;</span>
            idel_fd_ <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">accept</span><span class="token punctuation">(</span>socket_<span class="token punctuation">.</span><span class="token function">getFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">,</span> <span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token double-colon punctuation">::</span><span class="token function">close</span><span class="token punctuation">(</span>idel_fd_<span class="token punctuation">)</span><span class="token punctuation">;</span>
            idel_fd_ <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/null"</span><span class="token punctuation">,</span> O_RDONLY <span class="token operator">|</span> O_CLOEXEC<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>    <span class="token comment">// 表示正常返回,执行</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>newconnection_func_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">newconnection_func_</span><span class="token punctuation">(</span>accept_fd<span class="token punctuation">,</span> peer_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 执行回调函数</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
            <span class="token double-colon punctuation">::</span><span class="token function">close</span><span class="token punctuation">(</span>accept_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 关闭返回的socket</span>
        <span class="token punctuation">}</span> <span class="token comment">// 加入到该循环对应的epoll中</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><strong>借助idel_fd_处理文件描述符耗尽的问题</strong></p>
<p>如果在readHandle中由于文件描述符耗尽的原因,就会导致accept一直失败的问题,如果一直无法accept对该连接返回成功,该事件就一直得不到处理,导致在epoll_wait一直返回.在这里利用一个提前就分配好的idel_fd_,将该文件描述符关闭后,accept返回到idel_fd中,然后再关闭回到初始的状态,该连接所对应的事件就可以得到处理,也就不会留在epoll_wait中一直返回了.</p>
</blockquote>
<p>关于TcpConnection的实现则是比较复杂的:</p>
<ul>
<li>TcpConnection中的读、写、关闭、错误事件都需要设置相应的handle.不像Acceptor基本只用到了readHandle.</li>
<li>TcpConnection需要考虑数据的读写问题.读写问题需要结合非阻塞IO以及epoll水平触发的特点来设计.</li>
<li>对于连接关闭问题的处理较复杂,需要考虑此时进行读写行为的影响.</li>
</ul>
<blockquote>
<p><strong>TCP连接所需要关注的三个半问题</strong></p>
<p>这三个半问题指的是:连接的建立、数据的读写、连接关闭、连接关闭后的回调(算半个).</p>
<p>其中前三个问题是最为必要的,接下来将会围绕着这几个问题来展开介绍TcpConnection中的相关实现.</p>
</blockquote>
<p>关于连接的建立,需要结合Acceptor和TcpServer来进行分析,在前面我们已经知道Acceptor的readHandle中已经将到来的新连接获取了其对应的文件描述符以及地址,接下来要做的就是执行一个newconnection_func_(作为一个Acceotor的私有数据成员(函数回调类型的)),该回调函数由TcpServer提供,其实现如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">TcpServer</span><span class="token double-colon punctuation">::</span><span class="token function">newConnFunc</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> SockAddress <span class="token operator">&amp;</span>address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 首先获取一个io loop用来处理</span>
    <span class="token keyword keyword-auto">auto</span> io_loop <span class="token operator">=</span> pool_<span class="token operator">-&gt;</span><span class="token function">getNextLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 根据fd和address创建一个Connection</span>
    <span class="token keyword keyword-char">char</span> name_buf<span class="token punctuation">[</span>ip_<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>name_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>name_buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>name_buf<span class="token punctuation">,</span> <span class="token string">"#%s:%u:%u"</span><span class="token punctuation">,</span> ip_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> port_<span class="token punctuation">,</span> curr_conn_number_<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string conn_name <span class="token operator">=</span> name_buf<span class="token punctuation">;</span>
    sockaddr_in localaddr<span class="token punctuation">;</span>
    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>localaddr<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>localaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    socklen_t addrlen <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>socklen_t<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>localaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token double-colon punctuation">::</span><span class="token function">getsockname</span><span class="token punctuation">(</span>acceptor_<span class="token operator">-&gt;</span><span class="token function">getListeningFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>sockaddr<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>localaddr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>addrlen<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        LOG_ERROR <span class="token operator">&lt;&lt;</span> <span class="token string">"Get local sockname error in TcpServer, the acceptor fd is "</span> <span class="token operator">&lt;&lt;</span> acceptor_<span class="token operator">-&gt;</span><span class="token function">getListeningFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    SockAddress <span class="token function">local_address</span><span class="token punctuation">(</span>localaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> conn <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>TcpConnection<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>io_loop<span class="token punctuation">,</span> conn_name<span class="token punctuation">,</span> fd<span class="token punctuation">,</span>
                                                local_address<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
    connection_map_<span class="token punctuation">[</span>conn<span class="token operator">-&gt;</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> conn<span class="token punctuation">;</span>
    conn<span class="token operator">-&gt;</span><span class="token function">setCloseCallback</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpServer<span class="token double-colon punctuation">::</span>removeConnForClose<span class="token punctuation">,</span> <span class="token keyword keyword-this">this</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     
    conn<span class="token operator">-&gt;</span><span class="token function">setConnectionCallback</span><span class="token punctuation">(</span>connection_callback_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    conn<span class="token operator">-&gt;</span><span class="token function">setMessageCallback</span><span class="token punctuation">(</span>message_callback_<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 设置回调函数</span>

    io_loop<span class="token operator">-&gt;</span><span class="token function">runInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpConnection<span class="token double-colon punctuation">::</span>establish<span class="token punctuation">,</span> conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这一部分属于TcpServer部分的代码,将会在Acceptor所处的线程中执行,然后从线程池中挑选出一个io线程,该线程中的EventLoop(Epoller)将会用来监听这个新创建的连接.下面的过程就是创建一个TcpConnetion对象,并且加入到TcpServer的map中,并且设置好相关的回调函数,之后调用TcpConnetion中的establish函数,注意该函数是借助runInLoop,使其恰好运行在该TcpConnection所处的io线程中.因此也可以说连接的创立在网络库中是一个异步的过程.至于TcpConnection中的establish函数,其实现细节如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">establish</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// 该函数也要保证放在该loop所处的线程中处理</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>state_ <span class="token operator">==</span> Connecting<span class="token punctuation">)</span> <span class="token punctuation">{</span>			<span class="token comment">// Connecting表达的是一个尚未建立连接的状态,或者可以说是即将建立连接的意思</span>
        <span class="token function">setState</span><span class="token punctuation">(</span>ConnectionState<span class="token double-colon punctuation">::</span>Connected<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 设置成已经建立好连接</span>
        channel_<span class="token operator">-&gt;</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// tie</span>
        channel_<span class="token operator">-&gt;</span><span class="token function">setReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// channel注册可读事件到Epoller上</span>
    <span class="token punctuation">}</span>
    <span class="token function">connection_callback_</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 连接建立/销毁相关的回调</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中关于tie的设置,与Channel中事件回调中,是否需要判断悬垂指针有关.</p>
<blockquote>
<p><strong>tie的作用是什么?</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">&gt;</span> tie_<span class="token punctuation">;</span>
<span class="token keyword keyword-bool">bool</span> tied_<span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token class-name">Channel</span><span class="token double-colon punctuation">::</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    tie_ <span class="token operator">=</span> obj<span class="token punctuation">;</span>
    tied_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token class-name">Channel</span><span class="token double-colon punctuation">::</span><span class="token function">handleEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>tied_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> guard <span class="token operator">=</span> tie_<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>guard<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">handleEventWithGuard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        <span class="token function">handleEventWithGuard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用于判断该Channel对应的TcpConnection有没有被析构,防止handleEvent还未执行完就出现TcpConnection(包括其中的Channel)被析构的情况.</p>
</blockquote>
<p><strong>连接关闭分为两种,第一种是被动关闭,也就是client端断开了连接,第二种是server端主动断开连接,这两种处理方式不同</strong>.其中对于第一种,<strong>体现为该连接对应的事件在epoll_wait中返回为可读事件,但是::read返回值为0.</strong>正如同readHandle中的代码:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">readHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel_<span class="token operator">-&gt;</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-int">int</span> error_no<span class="token punctuation">;</span>
    ssize_t retn <span class="token operator">=</span> read_buffer_<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>channel_<span class="token operator">-&gt;</span><span class="token function">getFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>error_no<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>retn <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">//正常的读取</span>
        <span class="token function">message_callback_</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_buffer_<span class="token punctuation">,</span> <span class="token class-name">TimeStamp</span><span class="token double-colon punctuation">::</span><span class="token function">getNowTimeStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>retn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>			<span class="token comment">// 表明client端已经退出.</span>
        <span class="token function">closeHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        <span class="token function">errorHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>closeHandle中代码如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">closeHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        
    <span class="token function">setState</span><span class="token punctuation">(</span>ConnectionState<span class="token double-colon punctuation">::</span>DisConnected<span class="token punctuation">)</span><span class="token punctuation">;</span>
    channel_<span class="token operator">-&gt;</span><span class="token function">setDisable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    TcpConnectionPtr <span class="token function">conn</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close_callback_</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// close_callback_</span>
<span class="token keyword keyword-void">void</span> <span class="token class-name">TcpServer</span><span class="token double-colon punctuation">::</span><span class="token function">removeConnForClose</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> TcpConnectionPtr <span class="token operator">&amp;</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    loop_<span class="token operator">-&gt;</span><span class="token function">runInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpServer<span class="token double-colon punctuation">::</span>removeConnForCloseInLoop<span class="token punctuation">,</span> <span class="token keyword keyword-this">this</span><span class="token punctuation">,</span> conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token class-name">TcpServer</span><span class="token double-colon punctuation">::</span><span class="token function">removeConnForCloseInLoop</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> TcpConnectionPtr <span class="token operator">&amp;</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> findit <span class="token operator">=</span> connection_map_<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>conn<span class="token operator">-&gt;</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>findit <span class="token operator">!=</span> connection_map_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        connection_map_<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>findit<span class="token punctuation">)</span><span class="token punctuation">;</span>
        conn<span class="token operator">-&gt;</span><span class="token function">getLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">runInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpConnection<span class="token double-colon punctuation">::</span>destroy<span class="token punctuation">,</span>
                                             conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// TcpConnection::destory</span>
<span class="token keyword keyword-void">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    channel_<span class="token operator">-&gt;</span><span class="token function">setDisable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    channel_<span class="token operator">-&gt;</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">connection_callback_</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实其中所涉及的操作主要包含<strong>channel的移除和在TcpServer中map中的移除</strong>.由于one
loop per
thread的原则,这两部分动作还是需要分开的,其中读map中TcpConnection的移除作用与主线程(也就是TcpServer中的base
thread),
该channel的移除应该在该TcpConnection所处的io线程中,但是channel在TcpConnection中是通过std::unique_ptr管理的,在两个线程中究竟谁先移除这一点无法确定,我们期望的情况是TcpConnection能够等到channel的remove等操作做完之后在移除(析构).如果真的该TcpConnection在channel移除前就析构了,后面的channel就成了悬垂指针,channel的remove就不能成功了.因此在这里(closeHandle中)创建了一个临时的std::shared_ptr,使得该TcpConnection的总的引用计数+1,并且代入到close_callback(以及destroy),所以这个时候及时map中的erase调用后,TcpConnection的引用计数也不会是0,而是1.知道等到destory执行完之后,该TcpConnection对象才真正被析构.实质上就是<strong>延长该TcpConnection对象的生命周期直到destory运行完</strong>.当一个TcpConnection被析构的时候,其中的Socket也会被析构,因此close掉了.</p>
<p>然后就是server端主动关闭连接的行为,这里需要额外考虑的情况就是<strong>如果此时server端正在写应该怎么办?怎样保证client接收到的可读信息是完整的?</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 通常在服务端进行半关闭</span>
    <span class="token comment">// 要考虑到写操作的情况，如果当前不处于writable</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>ConnectionState<span class="token double-colon punctuation">::</span>DisConnecting<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 设置成Connecting,writeHandle中会有相应的判断</span>
    loop_<span class="token operator">-&gt;</span><span class="token function">runInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpConnection<span class="token double-colon punctuation">::</span>shutdownInLoop<span class="token punctuation">,</span> <span class="token keyword keyword-this">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">shutdownInLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel_<span class="token operator">-&gt;</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Socket</span><span class="token double-colon punctuation">::</span><span class="token function">shutdownWrite</span><span class="token punctuation">(</span>channel_<span class="token operator">-&gt;</span><span class="token function">getFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因此这里只考虑关闭对该socket的“写”,并且设置状态为DisConnecting.该DisConnecting作用在writeHandle中有所体现:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>write_buffer_<span class="token punctuation">.</span><span class="token function">getReadableSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 如果改写的东西都已经写完了</span>
    channel_<span class="token operator">-&gt;</span><span class="token function">disableWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 还需要考虑WriteComplete的情况及其回调函数</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>state_ <span class="token operator">==</span> ConnectionState<span class="token double-colon punctuation">::</span>DisConnecting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">shutdownInLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 执行未完全完成的关闭状态</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上分支对应了如果要写的数据都已经写完的时候,首先关闭channel的可写事件,然后如果状态为DisConnecting,表明之前调用过shutdown函数,也就是说server之前要主动关闭该连接.如果符合就调用shutdownInLoop,之后才正式的设置为“不可写”.</p>
<blockquote>
<p><strong>为什么这里不是彻底关闭(close),而是一个half-open
connection状态的连接</strong></p>
<p>此时我们可以确定我们确实已经将写缓冲区中的数据写入到该连接的fd上了,但是client端究竟有没有接收到,这一点我们无法确定,如果此时client还没有完全接收到完整的数据就close掉的话,就会造成client端接收的数据缺失.所以这里的shutdown不会调用close,只是调用shutdown,关闭“写”,使得server再后来无法再写入新的数据.</p>
<p>等到client端的readHandle中出现返回0时,才是真正close的时候.</p>
</blockquote>
<p>接下来说明关于TcpConnection上的读写操作,在此之前,首先需要说一下Buffer.这里的TcpConnection所使用的非阻塞IO,epoll又是水平触发,这些因素都对读写的方式有重要的影响.</p>
<blockquote>
<p><strong>Buffer对于“水平触发epoll+非阻塞socket”数据读写的必要性</strong></p>
<p>首先对于读数据来说,只要有可读数据就会一直返回,因此无法确定一次读入的数据究竟是不是完整的一个报文,因此对于所读入的数据需要有一个Buffer缓存起来.</p>
<p>对于写入的数据,::write不一定能够将所需要写的所有数据一次性地写入,因此需要有一个Buffer用来保存所需要写到数据,每成功写入一点Buffer就少一点,直到Buffer为空就可以视为这一段数据都送走了.</p>
</blockquote>
<p>首先来说一说read相关的.在readHandle中,首先只是将从连接上到来的数据先读入到inbuffer上,然后调用message_callback_.其中在网络应用中,往往有对于数据内容的解析,在这个解析的过程中,所读取到的数据才被分为了一个个数据包(报文).一个报文往往由多段读取的数据结果组成,因此最终一个报文的解析过程应该也分为好几步,因此TcpConnection中有一个数据成员context,表示的就是每次解析所保存的“上下文信息”,如下所示:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>any context_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>比如HttpServer中的onMessage函数:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">HttpServer</span><span class="token double-colon punctuation">::</span><span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> TcpServer<span class="token double-colon punctuation">::</span>TcpConnectionPtr <span class="token operator">&amp;</span>conn<span class="token punctuation">,</span> Buffer <span class="token operator">*</span>buffer<span class="token punctuation">,</span>
                           TimeStamp timestamp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    HttpParser<span class="token operator">*</span> parser <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">any_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>HttpParser<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>conn<span class="token operator">-&gt;</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 此时已经</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parser<span class="token operator">-&gt;</span><span class="token function">parsing</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 中间出现了错误</span>
        conn<span class="token operator">-&gt;</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"HTTP/1.1 400 Bad Request\r\n\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        conn<span class="token operator">-&gt;</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>parser<span class="token operator">-&gt;</span><span class="token function">isFinishAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">onRequest</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> parser<span class="token operator">-&gt;</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        parser<span class="token operator">-&gt;</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 同时清空</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在对于http的处理中,我们可以将HttpParser看作是一个解析报文的状态机,一边读取当前Buffer中的数据,一边根据解析的结果设置其中的HttpRequest,最终是否能够判断是一个完整的报文取决于是否根据合法格式解析完一整个报文.也就是其中的parser-&gt;isFinishAll()这个时候表示的是一个完整的Request报文已经解析完了.因此到这里可以说,<strong>网络库只负责处理TcpConnection上的可读事件,并将数据填充到Buffer中,至于Buffer中的数据如何解析和分包,则取决于用户定义的代码如何取出并解析字符串,属于业务逻辑的部分</strong>.网路库的用于代码中,对于较复杂的情况,需要定一个Context相关的class(也很类似于状态机),保存上次解析所得的结果,好使得后来的解析能够基于上次的结果进行.</p>
<p>之后是与写数据相关的东西.与之有关的是,TcpConnection所提供的外部接口send,当编写server端的用户代码时,经常需要调用.其具体实现如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>content<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// send的实际操作中可能涉及到IO，因此保证其放入到IO线程中操作</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>state_ <span class="token operator">==</span> ConnectionState<span class="token double-colon punctuation">::</span>Connected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>loop_<span class="token operator">-&gt;</span><span class="token function">isOuterThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            loop_<span class="token operator">-&gt;</span><span class="token function">runInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpConnection<span class="token double-colon punctuation">::</span>sendInLoop<span class="token punctuation">,</span> <span class="token keyword keyword-this">this</span><span class="token punctuation">,</span> content<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
            <span class="token function">sendInLoop</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">sendInLoop</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>content<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>state_ <span class="token operator">==</span> ConnectionState<span class="token double-colon punctuation">::</span>DisConnected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ssize_t wroten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> remain <span class="token operator">=</span> len<span class="token punctuation">;</span>
    <span class="token keyword keyword-bool">bool</span> has_error <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel_<span class="token operator">-&gt;</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> write_buffer_<span class="token punctuation">.</span><span class="token function">getReadableSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        wroten <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">write</span><span class="token punctuation">(</span>channel_<span class="token operator">-&gt;</span><span class="token function">getFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> content<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>wroten <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            remain <span class="token operator">-=</span> wroten<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
            LOG_ERROR <span class="token operator">&lt;&lt;</span> <span class="token string">"the send in loop error"</span><span class="token punctuation">;</span>
            has_error <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>remain <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>has_error<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 还有剩余的话,就先输出到buffer上</span>
        write_buffer_<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>content <span class="token operator">+</span> wroten<span class="token punctuation">,</span> remain<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel_<span class="token operator">-&gt;</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            channel_<span class="token operator">-&gt;</span><span class="token function">setWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在muduo中,还有与高水位写相关的回调,但是在这里我没有实现,我只保留了最主干的一些功能.简而言之,Buffer等本身并非线程安全,因此对于send操作还是通过runInLoop使得其只能运行在该TcpConnection所处的io线程中.在sendInLoop中,</p>
<blockquote>
<p><strong>在水平触发epoll+非阻塞socket中,如何控制write事件的开关?</strong></p>
<p>首先我们需要知道的是,在一般情况下,write事件的触发条件是什么?简而言之,只要内核中的buffer没有写满,就会一直在epoll_wait中返回可写事件,因此及时我们什么都不想写,也一直都会有这种事件返回,这根本就是无用的,浪费开销的行为.因此一直保持writable是不可取的.所以考虑的是一种,需要写时再打开,写完就立马关闭的方式.</p>
</blockquote>
<p>首先此时不是处于writable的状态,就先尝试直接通过::write写数据,如果直接就写完了,就可以不做多余的事情.否则,就将剩余的部分加入到write_buffer中,并且开启channel中的writable.剩余的部分就借助writeHandle,将缓冲区中的内容写入.当缓冲区中的数据为空时,表示的写结束.其中writeHandle的实现如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">writeHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel_<span class="token operator">-&gt;</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-int">int</span> error_no<span class="token punctuation">;</span>
    ssize_t retn <span class="token operator">=</span> write_buffer_<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>channel_<span class="token operator">-&gt;</span><span class="token function">getFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>error_no<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>retn <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        write_buffer_<span class="token punctuation">.</span><span class="token function">retrieve</span><span class="token punctuation">(</span>retn<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 移动write index</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>write_buffer_<span class="token punctuation">.</span><span class="token function">getReadableSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 如果改写的东西都已经写完了</span>
            channel_<span class="token operator">-&gt;</span><span class="token function">disableWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>state_ <span class="token operator">==</span> ConnectionState<span class="token double-colon punctuation">::</span>DisConnecting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">shutdownInLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 执行未完全完成的关闭状态</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        errno <span class="token operator">=</span> error_no<span class="token punctuation">;</span>
        LOG_ERROR <span class="token operator">&lt;&lt;</span> <span class="token string">"write error in write handle"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每次writeHandle就写一点,写完之后就关闭channel的writable.此时还考虑到如果此时有等待写操作的shutdown的情况.</p>
<p><strong>至此,可以说围绕着连接建立、关闭、数据读写,就可以将TcpConnection以及TcpServer中最核心的代码逻辑梳理完了.</strong></p>
<h2 id="经验与思考">3. 经验与思考</h2>
<h3 id="one-loop-per-thread和线程安全">1) one loop per
thread和线程安全</h3>
<p>one loop per
thread不仅仅是使得每个线程都运行一个循环体那么简单,更重要的一点是,每个线程都有特定职责,<strong>根据其职责使得对于某些对象的操作只能局限于某一个循环之中,</strong>因此原本因为某些对象可能会在不同线程中被操作而导致的data
race被化解,因此它们终将会在其所归属的线程中被操作.</p>
<p>正如每一个thread都与一个EventLoop相绑定一样,很多对象也都与某个EventLoop想绑定,进而也可以说这些对象都与唯一一个线程想绑定.比如说Acceptor对象,它必定和TcpServer中的Base
Loop相绑定;TcpConnection对象也将会和线程池中的某个IO
Loop绑定.因此一些涉及到对Acceptor进行的操作,比如说TcpServer中的start:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">TcpServer</span><span class="token double-colon punctuation">::</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>is_running_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    is_running_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    loop_<span class="token operator">-&gt;</span><span class="token function">runInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Acceptor<span class="token double-colon punctuation">::</span>listen<span class="token punctuation">,</span> acceptor_<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pool_<span class="token operator">-&gt;</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token class-name">Acceptor</span><span class="token double-colon punctuation">::</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  loop_<span class="token operator">-&gt;</span><span class="token function">assertInLoopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  listening_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  acceptSocket_<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  acceptChannel_<span class="token punctuation">.</span><span class="token function">enableReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显然是需要将Acceptor对象的listen操作runInLoop到Acceptor所绑定的线程中的.正是有了这种协议的保证,listen中对于内部数据的操作即使本身不是线程安全的,也没用锁去专门保护它们,但也能够防止线程安全.因为在runInLoop的保证下,无论是哪些线程调用了start,其中对于Acceptor对象的操作(listen)都转化到了一个线程中.</p>
<p>再举一个关于TcpConnection的例子,TcpConnection中的很多数据成员及其操作本身都不是线程安全的,尤其是读写Buffer.应对这种问题的方式仍然是runInloop,比如说:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>ConnectionState<span class="token double-colon punctuation">::</span>DisConnecting<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 设置成Connecting,writeHandle中会有相应的判断</span>
    loop_<span class="token operator">-&gt;</span><span class="token function">runInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpConnection<span class="token double-colon punctuation">::</span>shutdownInLoop<span class="token punctuation">,</span> <span class="token keyword keyword-this">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">shutdownInLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel_<span class="token operator">-&gt;</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Socket</span><span class="token double-colon punctuation">::</span><span class="token function">shutdownWrite</span><span class="token punctuation">(</span>channel_<span class="token operator">-&gt;</span><span class="token function">getFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中shutdown函数可以说是提供给上层的一个接口,它会在什么地方被用户代码调用是个不确定的问题,因此很有可能会出现被多个线程调用的问题.其中setState中的state变量本身就是一个std::atomic变量,保证了线程安全.但是对于channel-&gt;getFd的关闭操作需要专门放置到此channel所属的线程中.</p>
<p>说了这么多,runInLoop究竟是怎么实现的呢?</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">EventLoop</span><span class="token double-colon punctuation">::</span><span class="token function">runInLoop</span><span class="token punctuation">(</span>QueuedFunctor func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>func <span class="token operator">==</span> <span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 不可以为空</span>
        <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">isOuterThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 加入到队列里</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lockGuard</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>
            queued_list_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 唤醒loop,loop中将会处理被加入到队列中的函数</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>        <span class="token comment">// 直接运行</span>
        <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实这个地方仍然有锁开销,只不过临界区要短了许多,只针对任务队列.如果不遵守只运行在特定线程中的规则的话,也可以考虑通过锁来保护这些对象的操作,但是这样的临界区就会长很多,因此开销也就大得多.</p>
<p>总的来说,为了避免多个线程对某些对象操作所导致的线程安全问题,这种技术要求某个对象的操作必须局限于一个线程之中,如果有其他线程调用对该对象的操作,就将其操作转移到这个特定的线程之中去.</p>
<h3 id="通过stdfunctionstdbind来替代多态">2)
通过std::function+std::bind来替代多态</h3>
<p>C++中面向对象的继承与多态是使用起来很容出错,容易写出难以维护代码的特性.因此有些大佬建议,继承与多态能不用就不用.</p>
<p>当我们需要一种方法在不同的class中有多种不同的实现时,就想到用多态.然而多态有许多地方导致代码变得难以维护,比如说多态往往伴随着继承体系的建立,当程序不断演进时,有些class需要在继承体系上移动,这麻烦得很.此外,一个派生类很多时候只需要override一个或者一部分虚函数,但是多态的语法中却有要override所有虚函数的要求.</p>
<p>比如说一个Thread的设计,如果是常规的OO设计,会写一个Thread的基类,其中的run函数是需要被override的,还要有具体的实现类,用来将其中的run进行override.这种方式有个麻烦的地方在于,如果我们需要用到多个不同的run行为的Thread,就得定义多个实现类.</p>
<p>如果使用“std::bind+std::function”来替代多态的话,比如说:
</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-using">using</span> ThreadCallBack <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword keyword-void">void</span> <span class="token function">setThreadCallBack</span><span class="token punctuation">(</span>ThreadCallBack cb<span class="token punctuation">)</span> <span class="token punctuation">{</span> cb_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword keyword-private">private</span><span class="token operator">:</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">cb_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    ThreadCallBack cb_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<p>在这种方式下,如果我们想要创建出运行不同过程的Thread,只需要通过setThreadCallBack传递不同的function就好.在网络库中,Channel的相关设计也是如此,其中Channel的数据成员有一下回调:
</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">CallBackFunc read_callback_<span class="token punctuation">;</span>
CallBackFunc write_callback_<span class="token punctuation">;</span>
CallBackFunc close_callback_<span class="token punctuation">;</span>
CallBackFunc error_callback_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
以及相关的setCallBack的函数,如此在一些需要用到Channel实现的class中,比如TcpConnection、Acceptor中,只需要在类中借助std::bind设置Channel中的这些回调就好.如果采用基于OO的设计,则需要专门为TcpConnection、Acceptor再定义专门的TcpConnectionChannel,AcceotorChannel(并且它们都继承自Channel基类),因此就会变得复杂.<p></p>
<h3 id="onmessage回调少用栈上不定长buffer">3)
onMessage回调少用栈上不定长buffer</h3>
<p><strong>一个程序的所占用内存大小不应该随着其所处理数据的大小而增长</strong>.比如说:
</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">onConnection</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> TcpConnectionPtr <span class="token operator">&amp;</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>conn<span class="token operator">-&gt;</span><span class="token function">connected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        string fileContent <span class="token operator">=</span> <span class="token function">readFile</span><span class="token punctuation">(</span>g_file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        conn<span class="token operator">-&gt;</span><span class="token function">send</span><span class="token punctuation">(</span>fileContent<span class="token punctuation">)</span><span class="token punctuation">;</span>
        conn<span class="token operator">-&gt;</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
上述程序中的问题在于内存消耗会与文件大小有关,在大文件(GB以上)的情境下,有内存耗尽的风险.<p></p>
<p>对于这种问题的解决方式:<strong>我们可以每次只处理固定大小的内容,一个文件将会分为多次处理完</strong>,因此需要一个std::any来保存上下文.在上面的例子中,context可以是FILE*中文件偏移的位置.</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">1. 总体架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-number">2.</span> <span class="toc-text">2. 核心模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socketchannel"><span class="toc-number">2.1.</span> <span class="toc-text">1).Socket、Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epollereventloop"><span class="toc-number">2.2.</span> <span class="toc-text">2).Epoller、EventLoop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#acceptortcpconnectiontcpserver"><span class="toc-number">2.3.</span> <span class="toc-text">3).Acceptor、TcpConnection、TcpServer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E9%AA%8C%E4%B8%8E%E6%80%9D%E8%80%83"><span class="toc-number">3.</span> <span class="toc-text">3. 经验与思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#one-loop-per-thread%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">3.1.</span> <span class="toc-text">1) one loop per
thread和线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87stdfunctionstdbind%E6%9D%A5%E6%9B%BF%E4%BB%A3%E5%A4%9A%E6%80%81"><span class="toc-number">3.2.</span> <span class="toc-text">2)
通过std::function+std::bind来替代多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onmessage%E5%9B%9E%E8%B0%83%E5%B0%91%E7%94%A8%E6%A0%88%E4%B8%8A%E4%B8%8D%E5%AE%9A%E9%95%BFbuffer"><span class="toc-number">3.3.</span> <span class="toc-text">3)
onMessage回调少用栈上不定长buffer</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/012016887.html"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/012016887.html&text=记录一个网络库的核心实现"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/012016887.html&title=记录一个网络库的核心实现"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/012016887.html&is_video=false&description=记录一个网络库的核心实现"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=记录一个网络库的核心实现&body=Check out this article: http://example.com/2023/012016887.html"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/012016887.html&title=记录一个网络库的核心实现"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/012016887.html&title=记录一个网络库的核心实现"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/012016887.html&title=记录一个网络库的核心实现"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/012016887.html&title=记录一个网络库的核心实现"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/012016887.html&name=记录一个网络库的核心实现&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/012016887.html&t=记录一个网络库的核心实现"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    yfs
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
      --><li><a href="/">首页</a></li><!--
    --><!--
      --><li><a href="/about/">关于</a></li><!--
    --><!--
      --><li><a href="/archives/">归档</a></li><!--
    -->
      </ul>
      <ul>
        
          <!-- 不蒜子统计 -->
          <span id="busuanzi_container_site_pv">
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
          </span>
          <span class="post-meta-divider">|</span>
          <span id="busuanzi_container_site_uv" style='display:none'>
                  本站访客数<span id="busuanzi_value_site_uv"></span>人
          </span>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        
      </ul>
    </nav>
  </div>
  
</footer>

<script src="/js/prism/prism.js" async></script>


    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'cactus-1';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'owner/githubrepo';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>
