<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="大年初一时感觉有些无聊,感觉不如靠学习来打发时间.又想了想之前学过的关于数据库内核的项目几乎快要忘干净了,所以打算从今天开始,一直到开学,除了复习枯燥无味的专业课,再把SimpleDB以及BusTub这两个小数据库的源码啃一遍,希望能对数据库系统的实现有更完整和深入的理解吧. 1.存储引擎 存储引擎是数据库系统中直接对底层文件打交道的模块. 我认为这一模块的设计主要考虑了这几个问题:磁盘上文件中,">
<meta property="og:type" content="article">
<meta property="og:title" content="结合SimpleDB和BusTub复盘数据库内核实现">
<meta property="og:url" content="http://example.com/2023/012241324.html">
<meta property="og:site_name" content="Yfs&#39;s Box">
<meta property="og:description" content="大年初一时感觉有些无聊,感觉不如靠学习来打发时间.又想了想之前学过的关于数据库内核的项目几乎快要忘干净了,所以打算从今天开始,一直到开学,除了复习枯燥无味的专业课,再把SimpleDB以及BusTub这两个小数据库的源码啃一遍,希望能对数据库系统的实现有更完整和深入的理解吧. 1.存储引擎 存储引擎是数据库系统中直接对底层文件打交道的模块. 我认为这一模块的设计主要考虑了这几个问题:磁盘上文件中,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2027%2010%2036%2011%201674786971%201674786971113%20qyBKLt%20image-20230127103611015%20.png">
<meta property="og:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2030%2021%2033%2055%201675085635%201675085635907%20njmkBQ%20image-20230130213355721%20.png">
<meta property="article:published_time" content="2023-01-22T04:33:49.000Z">
<meta property="article:modified_time" content="2023-02-04T05:31:19.708Z">
<meta property="article:author" content="yfs">
<meta property="article:tag" content="数据库系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2027%2010%2036%2011%201674786971%201674786971113%20qyBKLt%20image-20230127103611015%20.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>结合SimpleDB和BusTub复盘数据库内核实现</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<link rel="stylesheet" href="/js/prism/prism.css">

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/012016887.html"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/012241324.html"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/012241324.html&text=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/012241324.html&title=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/012241324.html&is_video=false&description=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=结合SimpleDB和BusTub复盘数据库内核实现&body=Check out this article: http://example.com/2023/012241324.html"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/012241324.html&title=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/012241324.html&title=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/012241324.html&title=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/012241324.html&title=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/012241324.html&name=结合SimpleDB和BusTub复盘数据库内核实现&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/012241324.html&t=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.</span> <span class="toc-text">1.存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">1).内存模型与类型抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#value%E4%B8%8Etype"><span class="toc-number">1.1.1.</span> <span class="toc-text">value与type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tuple"><span class="toc-number">1.1.2.</span> <span class="toc-text">tuple</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E9%A1%B5"><span class="toc-number">1.2.</span> <span class="toc-text">2).文件分页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tablepage"><span class="toc-number">1.2.1.</span> <span class="toc-text">TablePage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tableheap"><span class="toc-number">1.2.2.</span> <span class="toc-text">TableHeap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.</span> <span class="toc-text">3).全局元数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98io"><span class="toc-number">1.4.</span> <span class="toc-text">4).磁盘I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-number">1.5.</span> <span class="toc-text">5).缓存池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text">6).小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">2.索引系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">1).内存数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="toc-number">2.2.</span> <span class="toc-text">2).索引文件组织</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="toc-number">3.</span> <span class="toc-text">3.查询与执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-number">3.1.</span> <span class="toc-text">1).执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#execution-engine"><span class="toc-number">3.1.1.</span> <span class="toc-text">Execution Engine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#expression"><span class="toc-number">3.1.2.</span> <span class="toc-text">Expression</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execution-plan"><span class="toc-number">3.1.3.</span> <span class="toc-text">Execution Plan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#executor"><span class="toc-number">3.1.4.</span> <span class="toc-text">Executor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2).优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#statistics"><span class="toc-number">3.2.1.</span> <span class="toc-text">Statistics</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#optimizer"><span class="toc-number">3.2.2.</span> <span class="toc-text">Optimizer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">4.事务与并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transactiontransactionmanager"><span class="toc-number">4.1.</span> <span class="toc-text">1).Transaction、TransactionManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lockmanager"><span class="toc-number">4.2.</span> <span class="toc-text">2).LockManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">4.3.</span> <span class="toc-text">3).小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%8F%8A%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">5.日志及恢复系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%86%E8%8A%82"><span class="toc-number">5.1.</span> <span class="toc-text">1).其他模块中的相关细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsn"><span class="toc-number">5.2.</span> <span class="toc-text">LSN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wal"><span class="toc-number">5.3.</span> <span class="toc-text">WAL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#logmanager"><span class="toc-number">5.4.</span> <span class="toc-text">2).LogManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#checkpointmanager"><span class="toc-number">5.5.</span> <span class="toc-text">3).CheckpointManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#logrecovery"><span class="toc-number">5.6.</span> <span class="toc-text">4).LogRecovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">5.7.</span> <span class="toc-text">5).小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E6%80%8E%E6%A0%B7%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">6.</span> <span class="toc-text">6.思考:怎样写一个数据库?</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        结合SimpleDB和BusTub复盘数据库内核实现
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">yfs</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-01-22T04:33:49.000Z" itemprop="datePublished">2023-01-22</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" rel="tag">数据库系统</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>大年初一时感觉有些无聊,感觉不如靠学习来打发时间.又想了想之前学过的关于数据库内核的项目几乎快要忘干净了,所以打算从今天开始,一直到开学,除了复习枯燥无味的专业课,再把SimpleDB以及BusTub这两个小数据库的源码啃一遍,希望能对数据库系统的实现有更完整和深入的理解吧.</p>
<h2 id="存储引擎">1.存储引擎</h2>
<p><strong>存储引擎是数据库系统中直接对底层文件打交道的模块.</strong>
我认为这一模块的设计主要考虑了这几个问题:磁盘上文件中,数据如何排列组织?文件中的数据在内存上如何抽象?数据库系统如何利用内存加速IO的?内存上的内容如何落到磁盘上的?</p>
<h3 id="内存模型与类型抽象">1).内存模型与类型抽象</h3>
<p><strong>这一部分主要解决的是磁盘中结构化的数据如何在内存中进行抽象的问题.</strong>
传统数据库系统所维护的数据在底层仍然是以文件的方式存储在disk上,但是数据库系统又有结构化存储的特点,<strong>因此文件内部的数据组织往往与数据库结构化存储相适应</strong>.比如说对于关系型的数据库来说,文件中的数据以一个个table的方式组织,table内部有分为了一行行的tuple,tuple内部有一个个字段(value),不同的字段又有各自不同的类型.</p>
<p>存储引擎是直接对这些文件进行读写的模块,就避免不了对于文件数据的结构化处理,也就是说要将文件的内容转化为特定的数据结构.正如上面所说的table、tuple、value等等.其中value是最细粒度的单位,tuple次之.</p>
<h4 id="value与type">value与type</h4>
<p>关于value相关的实现,在BusTub的Value中,其中数据成员如下: </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-union">union</span> Val <span class="token punctuation">{</span>     <span class="token comment">// 表示具体的值</span>
  <span class="token keyword keyword-int8_t">int8_t</span> boolean_<span class="token punctuation">;</span>
  <span class="token keyword keyword-int8_t">int8_t</span> tinyint_<span class="token punctuation">;</span>
  <span class="token keyword keyword-int16_t">int16_t</span> smallint_<span class="token punctuation">;</span>
  <span class="token keyword keyword-int32_t">int32_t</span> integer_<span class="token punctuation">;</span>
  <span class="token keyword keyword-int64_t">int64_t</span> bigint_<span class="token punctuation">;</span>
  <span class="token keyword keyword-double">double</span> decimal_<span class="token punctuation">;</span>
  <span class="token keyword keyword-uint64_t">uint64_t</span> timestamp_<span class="token punctuation">;</span>
  <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>varlen_<span class="token punctuation">;</span>
  <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>const_varlen_<span class="token punctuation">;</span>
<span class="token punctuation">}</span> value_<span class="token punctuation">;</span>
<span class="token keyword keyword-union">union</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-uint32_t">uint32_t</span> len_<span class="token punctuation">;</span>
  TypeId elem_type_id_<span class="token punctuation">;</span>
<span class="token punctuation">}</span> size_<span class="token punctuation">;</span>
<span class="token keyword keyword-bool">bool</span> manage_data_<span class="token punctuation">;</span>
TypeId type_id_<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
其中TypeId是一个表示类型的枚举类(一个整型),采用union来表示实际的值.此外Value之中定义了许多关于二元运算、比较等相关的函数,比如说:
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-inline">inline</span> Value <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> Value <span class="token operator">&amp;</span>o<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token class-name">Type</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span>type_id_<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword keyword-inline">inline</span> Value <span class="token function">Subtract</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> Value <span class="token operator">&amp;</span>o<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token class-name">Type</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span>type_id_<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">Subtract</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword keyword-inline">inline</span> Value <span class="token function">Multiply</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> Value <span class="token operator">&amp;</span>o<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token class-name">Type</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span>type_id_<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">Multiply</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword keyword-inline">inline</span> Value <span class="token function">Divide</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> Value <span class="token operator">&amp;</span>o<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token class-name">Type</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span>type_id_<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">Divide</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
其实都是基于Type实现的,Type是一个抽象基类,对于不同的数据类型有不同的派生类,比如说bitint、boolean、smallint等等,其中继承体系大致如下:<p></p>
<p>Type及其派生类都有什么,其实没有实际的数据成员(倒是有一个TypeId),但是为特定类型的Value提供了像二元运算、compare等操作Value的方法.并且这些不同的Type具体类都有一个全局的单例对象,看上面Value中的Add、Subtract、Multiply等方法都是先通过Type::GetInstance获取此类型的单例对象,并执行其提供的方法的.这是在Type基类中的数据成员,第二个数组存储了不同类型的单例Type对象.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token keyword keyword-protected">protected</span><span class="token operator">:</span>
  <span class="token comment">// The actual type ID</span>
  TypeId type_id_<span class="token punctuation">;</span>
  <span class="token comment">// Singleton instances.</span>
  <span class="token keyword keyword-static">static</span> Type <span class="token operator">*</span>k_types<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外Value对象是通过一个工厂类创建的,此工厂类除了创建还提供CastAs相关的函数.其中一部分实现:
</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 关于Get类函数,是通过Value的构造函数实现的.</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-inline">inline</span> Value <span class="token function">GetTinyIntValue</span><span class="token punctuation">(</span><span class="token keyword keyword-int8_t">int8_t</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token function">Value</span><span class="token punctuation">(</span>TypeId<span class="token double-colon punctuation">::</span>TINYINT<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-inline">inline</span> Value <span class="token function">GetSmallIntValue</span><span class="token punctuation">(</span><span class="token keyword keyword-int16_t">int16_t</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token function">Value</span><span class="token punctuation">(</span>TypeId<span class="token double-colon punctuation">::</span>SMALLINT<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-inline">inline</span> Value <span class="token function">GetIntegerValue</span><span class="token punctuation">(</span><span class="token keyword keyword-int32_t">int32_t</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token function">Value</span><span class="token punctuation">(</span>TypeId<span class="token double-colon punctuation">::</span>INTEGER<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">// CastAs相关</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-inline">inline</span> Value <span class="token function">CastAsTinyInt</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> Value <span class="token operator">&amp;</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-inline">inline</span> Value <span class="token function">CastAsDecimal</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> Value <span class="token operator">&amp;</span>value<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
所以,就Value在BusTub的相关实现来说,通过union实现对Value不同类型的值的存储,通过枚举类型TypeId表示该Value的类型,Value中确实实现了许多有关于Value的方法,这些方法都是对每个类型的全局单例对象中的方法的wrapper,而这些不同类型的Type,又是基于多态与继承设计的.<p></p>
<h4 id="tuple">tuple</h4>
<p>搞清楚tuple的存储视图是最最重要的.<strong>尤其是支持VARCHAR类型变量的Tuple的内存布局</strong>.在BusTub中,其视图大致如下:
</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">*</span> Tuple format<span class="token operator">:</span>
<span class="token operator">*</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token operator">*</span> <span class="token operator">|</span> FIXED<span class="token operator">-</span>SIZE <span class="token operator">or</span> VARIED<span class="token operator">-</span>SIZED OFFSET <span class="token operator">|</span> PAYLOAD OF VARIED<span class="token operator">-</span>SIZED FIELD <span class="token operator">|</span>
<span class="token operator">*</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<strong>Tuple对象有一个专门用来保存数据缓冲区</strong>.在一个Tuple中,前半部分用于<strong>存储定长字段的值或者不定长字段的指offset</strong>,后一段存储的是不定长字段的值.其中前半段的长度是可以根据该Tuple所属的Schema确定好的.下面是Tuple类的构造函数:
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">Tuple</span><span class="token double-colon punctuation">::</span><span class="token function">Tuple</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Value<span class="token operator">&gt;</span> values<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> Schema <span class="token operator">*</span>schema<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">allocated_</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> schema<span class="token operator">-&gt;</span><span class="token function">GetColumnCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 1. Calculate the size of the tuple.</span>
  <span class="token keyword keyword-uint32_t">uint32_t</span> tuple_size <span class="token operator">=</span> schema<span class="token operator">-&gt;</span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>i <span class="token operator">:</span> schema<span class="token operator">-&gt;</span><span class="token function">GetUnlinedColumns</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    tuple_size <span class="token operator">+=</span> <span class="token punctuation">(</span>values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-uint32_t">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 2. Allocate memory.</span>
  size_ <span class="token operator">=</span> tuple_size<span class="token punctuation">;</span>
  data_ <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token keyword keyword-char">char</span><span class="token punctuation">[</span>size_<span class="token punctuation">]</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span><span class="token function">memset</span><span class="token punctuation">(</span>data_<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 3. Serialize each attribute based on the input value.</span>
  <span class="token keyword keyword-uint32_t">uint32_t</span> column_count <span class="token operator">=</span> schema<span class="token operator">-&gt;</span><span class="token function">GetColumnCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-uint32_t">uint32_t</span> offset <span class="token operator">=</span> schema<span class="token operator">-&gt;</span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
  <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-uint32_t">uint32_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> column_count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// 这其中对uninline的写入比较困难</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>col <span class="token operator">=</span> schema<span class="token operator">-&gt;</span><span class="token function">GetColumn</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>col<span class="token punctuation">.</span><span class="token function">IsInlined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Serialize relative offset, where the actual varchar data is stored.</span>
      <span class="token operator">*</span><span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword keyword-uint32_t">uint32_t</span> <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>data_ <span class="token operator">+</span> col<span class="token punctuation">.</span><span class="token function">GetOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> offset<span class="token punctuation">;</span>
      <span class="token comment">// Serialize varchar value, in place (size+data).</span>
      values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">SerializeTo</span><span class="token punctuation">(</span>data_ <span class="token operator">+</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
      offset <span class="token operator">+=</span> <span class="token punctuation">(</span>values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-uint32_t">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
      values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">SerializeTo</span><span class="token punctuation">(</span>data_ <span class="token operator">+</span> col<span class="token punctuation">.</span><span class="token function">GetOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
其中第一部分用于根据schema以及values计算出一个Tuple总共需要的size,分配出内存空间,然后遍历Value将其内容写入(Schema对象中本身就确定出了每个字段的起始偏移),对于inline类型的(也就是非VARCHAR类型的),直接通过schema中确定好的col偏移量写入对应的缓冲区即可,如果是VARCHAR类型的,只是先写入offset(可变量值的地址),然后在后半段中写入可变量的具体值.<p></p>
<p>在BusTub中的Tuple的数据成员如下: </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-bool">bool</span> allocated_<span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// is allocated?</span>
RID rid_<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>              <span class="token comment">// if pointing to the table heap, the rid is valid</span>
<span class="token keyword keyword-uint32_t">uint32_t</span> size_<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        
<span class="token keyword keyword-char">char</span> <span class="token operator">*</span>data_<span class="token punctuation">{</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
一个tuple的实际内容实际上存储在一个缓冲区中(data_).处于分配存储空间大小的需要,需要一个size_明确所需要空间的大小.其中RID表示的是一个页之中,该Tuple的编号.<p></p>
<blockquote>
<p><strong>VARCHAR类型的字段为什么要将地址和值的存储相分离?</strong></p>
</blockquote>
<h3 id="文件分页">2).文件分页</h3>
<p>了解了Value(字段)、Tuple(关系元组)在内存中的抽象之后,那么Table及其相关的文件又是如何组织的呢?在BusTub中,一个文件往往对应了一个表(一个表可以由多个文件组成),下面结合其中的Page以及TablePage进行剖析.</p>
<h4 id="tablepage">TablePage</h4>
<p>在BusTub中,一个Page对象对应磁盘上的一个block,其大小为4kb,只不过前者是加载于内存上的概念,后者是在磁盘上的概念.因此一个Page对象中,也会有一个buffer(4kb大小)来存储数据,也就是下面的data_,其数据成员如下:
</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-char">char</span> data_<span class="token punctuation">[</span>PAGE_SIZE<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
page_id_t page_id_ <span class="token operator">=</span> INVALID_PAGE_ID<span class="token punctuation">;</span>         <span class="token comment">// 页号,与某个block号对应</span>
<span class="token keyword keyword-int">int</span> pin_count_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword keyword-bool">bool</span> is_dirty_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
ReaderWriterLatch rwlatch_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre> 由于Page及其派生类对象需要被上层(buffer
pool)进行调用操作,其中pin_count_、is_dirty_与buffer
pool的机制有关,rwlatch_则是在并发处理中的锁.TablePage是Page的一个派生类,也展现了一种table在文件中的常规的表示方式.其组织方式如下:<p></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/**
 * Slotted page format:
 *  ---------------------------------------------------------
 *  | HEADER | ... FREE SPACE ... | ... INSERTED TUPLES ... |
 *  ---------------------------------------------------------
 *                                ^
 *                                free space pointer
 *
 *  Header format (size in bytes):
 *  ----------------------------------------------------------------------------
 *  | PageId (4)| LSN (4)| PrevPageId (4)| NextPageId (4)| FreeSpacePointer(4) |
 *  ----------------------------------------------------------------------------
 *  ----------------------------------------------------------------
 *  | TupleCount (4) | Tuple_1 offset (4) | Tuple_1 size (4) | ... |
 *  ----------------------------------------------------------------
 *
 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>HEADER部分表示整个TablePage的元数据.其中TablePage以一种类似于链式的方式维护,所以有PrevPageId和NextPageId作为指针.FreeSpacePointer表示一个文件中的偏移量,该偏移量从文件末尾开始,向低处增长(因为Tuple数据的增长和header中的增长呈现相反的方向),TupleCount表示的是当前所存储的Tuple的数量.后面的空间则存储了每个Tuple的offset和size.<strong>HEADER部分向文件高偏移处增长</strong>.</p></li>
<li><p>INSERTED
TUPLES部分用来存储已经插入到此Table的tuples.<strong>由于在HEADER中每个Tuple的offset和size可以固定地确定为8
bytes,所以可以在HEADER中明确地划分为一个个slot,每个slot就像数组一样可以通过索引访问</strong>.当通过某个index访问某个slot时,就可以获取其中的offset以及size,从而直接在INSERTED
TUPLES中定位该Tuple.<strong>INSERTED
TUPLES部分由高向低增长</strong>.</p></li>
</ul>
<blockquote>
<p><strong>关于Tuple size</strong></p>
<p>该位置的内容当为0时,表示的是该slot下没有插入Tuple.如果该slot有Tuple插入,就将该Tuple的size写入.此外,最高位留出来,用来做delete标记.</p>
</blockquote>
<p>明确了TablePage的组织方式之后,简单地说一说Tuple的Insert、Update和Delete:</p>
<ul>
<li>Insert:
<ul>
<li>从0开始遍历slot,直到找到一个slot中的Tuple size为empty.</li>
<li>根据该Tuple的size向低处移动FreeSpacePointer,并将Tuple中的数据拷贝.</li>
<li>设置好该slot下的size和offset.</li>
</ul></li>
<li>Update,需要调整该slot对应的offset、size.并且其对应的数据也要重置,此外还需要将FreeSpacePointer还有高处的Tuple进行移动,并且重置offset.</li>
<li>Delete.分为了两个阶段,一个是<code>MarkDelete</code>(只是将Tuple
size中的最高位设置为1),另一个是<code>ApplyDelete</code>:清空对应的数据区、HEADER中的Tuple
size和Tuple
offset;移动FreeSpacePointer指针,并且调整其他Tuple的offset.</li>
</ul>
<blockquote>
<p><strong>这里的Delete行为为什么要分成两段式地处理呢?</strong></p>
</blockquote>
<p>其实这里还牵扯到一些与日志及恢复系统相关的东西,暂且先不深究.</p>
<h4 id="tableheap">TableHeap</h4>
<p><strong>一个TableHeap是一个存储在磁盘上的table的抽象</strong>.一个表往往由多个Page组成,这些Page以某种数据结构组织着,这里以最简单朴素的list为例,也就是TablePage所采用的方式.简而言之,<strong>一个表可以由TablePage所组成的list表示(至于B+树、Hash那些涉及到索引的先不说)</strong>.</p>
<p>一个TableHeap中的数据成员如下: </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BufferPoolManager <span class="token operator">*</span>buffer_pool_manager_<span class="token punctuation">;</span>
LockManager <span class="token operator">*</span>lock_manager_<span class="token punctuation">;</span>
LogManager <span class="token operator">*</span>log_manager_<span class="token punctuation">;</span>
page_id_t first_page_id_<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>			<span class="token comment">// 该TableHeap的起始page所对应的id</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<p><strong>一个TableHeap中维护了组成一个表的所有TablePage的集合.</strong></p>
<p>其中<code>buffer_pool_manager</code>是因为TableHeap相关的API内部实现中,涉及到对Page的访问,其中获取某个TablePage的操作,往往是通过一个BufferPoolManager(缓存池)完成的.<code>TableHeap</code>提供了对一个table的操作的基本接口,比如说Update、Insert、Delete等等:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-bool">bool</span> <span class="token function">InsertTuple</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> Tuple <span class="token operator">&amp;</span>tuple<span class="token punctuation">,</span> RID <span class="token operator">*</span>rid<span class="token punctuation">,</span> Transaction <span class="token operator">*</span>txn<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 向该TableHeap插入一个Tuple</span>
<span class="token keyword keyword-bool">bool</span> <span class="token function">MarkDelete</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> RID <span class="token operator">&amp;</span>rid<span class="token punctuation">,</span> Transaction <span class="token operator">*</span>txn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 标记:从该TableHeap移除一个Tuple(通过rid)</span>
<span class="token keyword keyword-bool">bool</span> <span class="token function">UpdateTuple</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> Tuple <span class="token operator">&amp;</span>tuple<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> RID <span class="token operator">&amp;</span>rid<span class="token punctuation">,</span> Transaction <span class="token operator">*</span>txn<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 将rid对应的Tuple更新</span>
<span class="token keyword keyword-void">void</span> <span class="token function">ApplyDelete</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> RID <span class="token operator">&amp;</span>rid<span class="token punctuation">,</span> Transaction <span class="token operator">*</span>txn<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 从该TableHeap移除一个Tuple(通过rid)</span>
<span class="token keyword keyword-void">void</span> <span class="token function">RollbackDelete</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> RID <span class="token operator">&amp;</span>rid<span class="token punctuation">,</span> Transaction <span class="token operator">*</span>txn<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><u>Latch与Pin</u></p>
<p>在InsertTuple、MarkDelete、UpdateTuple等方法的实现中,往往需要对某些TablePage进行读写,在获取并操作某个TablePage时往往有如下的模式:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-auto">auto</span> page <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>TablePage <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>buffer_pool_manager_<span class="token operator">-&gt;</span><span class="token function">FetchPage</span><span class="token punctuation">(</span>rid<span class="token punctuation">.</span><span class="token function">GetPageId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 获取某个TablePage,FetchPage中有对该页的Pin操作.</span>
page<span class="token operator">-&gt;</span><span class="token function">RLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 上读锁(或者是page-&gt;WLacth为上写锁)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token comment">// reading operate for this page</span>
page<span class="token operator">-&gt;</span><span class="token function">RUnlatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 解开读锁</span>
buffer_pool_manager_<span class="token operator">-&gt;</span><span class="token function">UnpinPage</span><span class="token punctuation">(</span>rid<span class="token punctuation">.</span><span class="token function">GetPageId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// Unpin</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这其中既有BufferPool中需要的Pin操作,也有保证线程安全的锁操作.其中Pin操作是为了防止该TablePage在该TablePage被操作的期间防止被从BufferPool上踢出,Latch实质上是该TablePage中的std::mutex,防止多线程读写该页所带来的data
race问题.</p>
</blockquote>
<h3 id="全局元数据">3).全局元数据</h3>
<p><strong>BusTub有一个全局单例的Catalog对象</strong>.该对象维护了整个数据库系统中创建过的表、索引等实例,并且提供了访问这些实例的接口,也就是说,如果在User代码中想要获取或设置某个Table或者Index对象,都需要先通过Catalog中的get或set函数来进行.</p>
<p>Catalog中的数据成员如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token punctuation">[</span>maybe_unused<span class="token punctuation">]</span><span class="token punctuation">]</span> BufferPoolManager <span class="token operator">*</span>bpm_<span class="token punctuation">;</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span>maybe_unused<span class="token punctuation">]</span><span class="token punctuation">]</span> LockManager <span class="token operator">*</span>lock_manager_<span class="token punctuation">;</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span>maybe_unused<span class="token punctuation">]</span><span class="token punctuation">]</span> LogManager <span class="token operator">*</span>log_manager_<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>table_oid_t<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>TableInfo<span class="token operator">&gt;&gt;</span> tables_<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> table_oid_t<span class="token operator">&gt;</span> table_names_<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>table_oid_t<span class="token operator">&gt;</span> next_table_oid_<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>index_oid_t<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>IndexInfo<span class="token operator">&gt;&gt;</span> indexes_<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> index_oid_t<span class="token operator">&gt;&gt;</span> index_names_<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>index_oid_t<span class="token operator">&gt;</span> next_index_oid_<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>next_table_oid_</code>变量用于给创建的table分配编号.<code>tables_</code>中维护了TableInfo对象,TableInfo的实现如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">TableInfo</span> <span class="token punctuation">{</span>
  <span class="token function">TableInfo</span><span class="token punctuation">(</span>Schema schema<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>TableHeap<span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span>table<span class="token punctuation">,</span> table_oid_t oid<span class="token punctuation">)</span>
      <span class="token operator">:</span> schema_<span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>schema<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> name_<span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> table_<span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> oid_<span class="token punctuation">{</span>oid<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  Schema schema_<span class="token punctuation">;</span>
  <span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>TableHeap<span class="token operator">&gt;</span> table_<span class="token punctuation">;</span>
  <span class="token keyword keyword-const">const</span> table_oid_t oid_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>总的来说,基于这几个map就可以完成对某个Table或者Index对象的访问、设置或者创建.</p>
<p><strong>全局元数据不仅仅通过Catalog对象的方式维护在内存中,也需要有持久化在磁盘中的方式</strong>.BusTub中定义了HeaderPage,也就是说会有一个HeaderPage文件持久化了这些元数据的内容.</p>
<h3 id="磁盘io">4).磁盘I/O</h3>
<p>其实在BusTub中,<strong>所需要写的文件分为log文件和db文件,后者包含了数据库存储的数据.</strong>可以说,整个数据库系统就只有一个db文件,所有的表和索引都存储于其中.只不过通过分页的方式,将该db文件划分为了一个个页(在磁盘中恰好是一个block的大小),page_id也就是某个page在db文件之中的序号(比如说0-4095段对应了page_id为0,4096-8191对应的是page_id为1,以此类推),每个Table或者Index都由一个或者几个Page组成.</p>
<p>其中提供了读写Page相关的方法:<code>WritePage</code>和<code>ReadPage</code>:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">DiskManager</span><span class="token double-colon punctuation">::</span><span class="token function">WritePage</span><span class="token punctuation">(</span>page_id_t page_id<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>page_data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>scoped_lock <span class="token function">scoped_db_io_latch</span><span class="token punctuation">(</span>db_io_latch_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  size_t offset <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>page_id<span class="token punctuation">)</span> <span class="token operator">*</span> PAGE_SIZE<span class="token punctuation">;</span>
  num_writes_ <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  db_io_<span class="token punctuation">.</span><span class="token function">seekp</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 移动文件游标到该Page的起始位置</span>
  db_io_<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>page_data<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 写入缓冲区的数据</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>db_io_<span class="token punctuation">.</span><span class="token function">bad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"I/O error while writing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  db_io_<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token class-name">DiskManager</span><span class="token double-colon punctuation">::</span><span class="token function">ReadPage</span><span class="token punctuation">(</span>page_id_t page_id<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>page_data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>scoped_lock <span class="token function">scoped_db_io_latch</span><span class="token punctuation">(</span>db_io_latch_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-int">int</span> offset <span class="token operator">=</span> page_id <span class="token operator">*</span> PAGE_SIZE<span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>offset <span class="token operator">&gt;</span> <span class="token function">GetFileSize</span><span class="token punctuation">(</span>file_name_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"I/O error reading past end of file"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
    db_io_<span class="token punctuation">.</span><span class="token function">seekp</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 移动文件游标到该Page的起始位置</span>
    db_io_<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>page_data<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 读取一个Page的大小</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>db_io_<span class="token punctuation">.</span><span class="token function">bad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"I/O error while reading"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-int">int</span> read_count <span class="token operator">=</span> db_io_<span class="token punctuation">.</span><span class="token function">gcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>read_count <span class="token operator">&lt;</span> PAGE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>			<span class="token comment">// 判断是否读取完整</span>
      <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"Read less than a page"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      db_io_<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">memset</span><span class="token punctuation">(</span>page_data <span class="token operator">+</span> read_count<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PAGE_SIZE <span class="token operator">-</span> read_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于fstream不是线程安全的,所以还需要额外用一个锁用来保护.</p>
<h3 id="缓存池">5).缓存池</h3>
<p>缓存池可以说是存储引擎中最最核心的设计,数据库系统作为一种IO密集型的系统,如果所有对数据的读写操作都直接以磁盘读写的方式进行,将会带来不可接受的开销.<strong>因此缓存池的设计旨在尽可能地将数据读写作用在内存而非磁盘上,在某个时机再将缓存池中的内容刷到磁盘上.</strong></p>
<p>这其中实现和设计的难点在于:<strong>置换策略和Pin的处理</strong>.更多细节就参考我之前写过的一篇:<a target="_blank" rel="noopener" href="https://yfsbox.github.io/2022/101047594.html">CMU 15-445:project
#1 - Buffer Pool</a></p>
<h3 id="小结">6).小结</h3>
<p>如果暂且不考虑Logger的话,存储引擎的总体架构如下(<strong>这个图自己画的,好看不?</strong>):</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2027%2010%2036%2011%201674786971%201674786971113%20qyBKLt%20image-20230127103611015%20.png" alt="image-20230127103611015" style="zoom: 50%;"></p>
<p>其中暂时不包含索引、日志、Lock等方面的细节.最终总结如下:</p>
<ul>
<li><strong>DataBase
File.</strong>重点在于,如何划分为一个个的Page,以及Page内部数据的组织格式.</li>
<li><strong>Disk
Manager.</strong>需要这么一个从disk到内存的读写数据的搬运工,BufferPool中涉及到对Page进行读写的操作都是基于Disk
Manager完成的.</li>
<li><strong>数据模型.</strong>从最最基础的Type和Value,到Tuple,需要考虑的是Tuple如何处理可变长的Value?再到Table,Table是如何抽象的呢?可以说一个Table在BusTub中对应了一个TableHeap,一个TableHeap是一个或者多个Page的集合,这一部分又很多繁琐的代码.</li>
<li><strong>Catalog</strong>.用来在内存中保存全局元数据,比如说Table和Index的相关的信息.使得执行引擎可以通过一些get方法访问到某个特定的Table或者Index.</li>
<li><strong>Buffer
Pool</strong>.利用系统的局部性原理,尽可能地将对数据的操作转移到内存中,Disk文件之所以需要分页,很大程度上是为了适应BufferPool存储的要求.其中对内存页的Pin以及置换策略是实现Buffer
Pool的关键.</li>
</ul>
<h2 id="索引系统">2.索引系统</h2>
<p><strong>索引系统常常被看作是存储引擎的一部分.</strong>在这里单独拎出来了.</p>
<h3 id="内存数据结构">1).内存数据结构</h3>
<p>这里只讲解宏观、框架性质的东西,索引及其操作的实现细节,其中关于可拓展hash请见:<a target="_blank" rel="noopener" href="https://yfsbox.github.io/2022/101950754.html">CMU 15-445:project
#2 - Hash Index</a>.</p>
<h3 id="索引文件组织">2).索引文件组织</h3>
<h2 id="查询与执行">3.查询与执行</h2>
<p>在数据库中,数据库将接受的SQL执行经过编译(以及优化)之后可以得到一个呈现树状的Query
Plan,该Query将会被执行引擎执行(伴随着对存储引擎的访问),执行器运行结束后会产生结果.其大致的流程图如下:</p>
<p><img src="https://yfspicturebad1-1309550486.cos.ap-nanjing.myqcloud.com/uPic/2023%2001%2030%2021%2033%2055%201675085635%201675085635907%20njmkBQ%20image-20230130213355721%20.png" alt="image-20230130213355721" style="zoom:50%;"></p>
<p>BusTub中只涉及到执行引擎的实现.也就是<code>execution plan、evaluation engine</code>的部分,其中对data的操作是通过调用存储引擎的接口实现的,比如说Buffer
Pool中对于页的读、写等.</p>
<h3 id="执行引擎">1).执行引擎</h3>
<p>这一部分结合BusTub中的相关实现进行说明.其实现主要分为这几部分:</p>
<ul>
<li><strong>Plan Node的表示以及实现.</strong>Plan
Node时通过查询或者操作命令所转换成的一种类似于AST的树状结构.根据不同的命令类型,结点有不同的类型,比如说delete、update、insert等.这一部分之所以呈现为树状的结构,不仅仅是为了便于语句的抽象与表示,也是因为SQL操作本身具有层次依赖性,比如说Limit限制数量的是来源于子结点产生的Tuple.</li>
<li><strong>Executor的实现</strong>.既然Plan
Node组成的了一棵树,那么我们需要对这个树进行遍历,在遍历每个结点时执行相应的操作,才可以产生最终的结果,在遍历每个Plan
Node时,都会有一个Executor去执行相应的操作,正是因为有不同类型的Plan
Node,因此也会有不同类型的Executor对应不同的Plan
Node.<strong>Executor会有对存储引擎的直接访问,从中读、写Tuples</strong>.正是因为每个Plan
Node都会有相应的Executor处理,因此总体来看,一系列Execution
Plan的执行,也会有一个"Executors Tree".</li>
<li><strong>执行引擎以及总体结构</strong>.在BusTub中,执行引擎接收一个Plan
Tree(根),然后创建相应的Executor,然后调用Executor,返回结果.</li>
<li><strong>Expression的实现</strong>.</li>
</ul>
<h4 id="execution-engine">Execution Engine</h4>
<p>这一部分,起到一个“总管家”的身份,执行引擎中承上启下的一环(上:Execution
Plan,下:存储引擎).在BusTub中的实现比较简单:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-bool">bool</span> <span class="token function">Execute</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> AbstractPlanNode <span class="token operator">*</span>plan<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Tuple<span class="token operator">&gt;</span> <span class="token operator">*</span>result_set<span class="token punctuation">,</span> Transaction <span class="token operator">*</span>txn<span class="token punctuation">,</span>
             ExecutorContext <span class="token operator">*</span>exec_ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Construct and executor for the plan</span>
  <span class="token keyword keyword-auto">auto</span> executor <span class="token operator">=</span> <span class="token class-name">ExecutorFactory</span><span class="token double-colon punctuation">::</span><span class="token function">CreateExecutor</span><span class="token punctuation">(</span>exec_ctx<span class="token punctuation">,</span> plan<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Prepare the root executor</span>
  executor<span class="token operator">-&gt;</span><span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 使用每个执行器执行Plan Node,首先调用Init,然后在while循环中调用Next</span>
  <span class="token comment">// Execute the query plan</span>
  <span class="token keyword keyword-try">try</span> <span class="token punctuation">{</span>
    Tuple tuple<span class="token punctuation">;</span>
    RID rid<span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>executor<span class="token operator">-&gt;</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tuple<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 将tuple返回到结果集合中</span>
      <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>result_set <span class="token operator">!=</span> <span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result_set<span class="token operator">-&gt;</span><span class="token function">push_back</span><span class="token punctuation">(</span>tuple<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword keyword-catch">catch</span> <span class="token punctuation">(</span>Exception <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// TODO(student): handle exceptions</span>
  <span class="token punctuation">}</span>
  <span class="token keyword keyword-return">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对外只有一个接口.其中的内容,就是根据plan创建一个exector,将其初始化之后对executor进行遍历(执行),最终得到返回结果.exector看似只是一个单独的对象,但实际上和这个plan来说都是一个树状的结构,结合<code>ExecutorFactory::CreateExecutor</code>以及Executor的相关实现可以验证.如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-static">static</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> AbstractExpression <span class="token operator">*</span><span class="token operator">&gt;</span> empty_agg_exprs<span class="token punctuation">;</span>
<span class="token keyword keyword-static">static</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>AggregationType<span class="token operator">&gt;</span> empty_agg_types<span class="token punctuation">;</span>
<span class="token comment">/** The distinct plan node to be executed */</span>
<span class="token keyword keyword-const">const</span> DistinctPlanNode <span class="token operator">*</span>plan_<span class="token punctuation">;</span>
<span class="token comment">/** The child executor from which tuples are obtained */</span>
std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>AbstractExecutor<span class="token operator">&gt;</span> child_executor_<span class="token punctuation">;</span>
SimpleAggregationHashTable aht_<span class="token punctuation">;</span>
SimpleAggregationHashTable<span class="token double-colon punctuation">::</span>Iterator aht_iterator_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面是<code>DistinctExecutor</code>的数据成员,其中有一个<code>child_executor_</code>作为数据成员,也就是“子结点”.很多其他类型的Executor也是这样,也会有一个或者更多<code>child_executor_</code>作为数据成员.因此<code>ExecutorFactory::CreateExecutor</code>,也是以一种递归的方式创建Executor的:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-case">case</span> PlanType<span class="token double-colon punctuation">::</span>Insert<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> insert_plan <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> InsertPlanNode <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>plan<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> child_executor <span class="token operator">=</span>
        insert_plan<span class="token operator">-&gt;</span><span class="token function">IsRawInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword keyword-nullptr">nullptr</span> <span class="token operator">:</span> <span class="token class-name">ExecutorFactory</span><span class="token double-colon punctuation">::</span><span class="token function">CreateExecutor</span><span class="token punctuation">(</span>exec_ctx<span class="token punctuation">,</span> insert_plan<span class="token operator">-&gt;</span><span class="token function">GetChildPlan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>InsertExecutor<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>exec_ctx<span class="token punctuation">,</span> insert_plan<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>child_executor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// Create a new update executor</span>
  <span class="token keyword keyword-case">case</span> PlanType<span class="token double-colon punctuation">::</span>Update<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> update_plan <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> UpdatePlanNode <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>plan<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> child_executor <span class="token operator">=</span> <span class="token class-name">ExecutorFactory</span><span class="token double-colon punctuation">::</span><span class="token function">CreateExecutor</span><span class="token punctuation">(</span>exec_ctx<span class="token punctuation">,</span> update_plan<span class="token operator">-&gt;</span><span class="token function">GetChildPlan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>UpdateExecutor<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>exec_ctx<span class="token punctuation">,</span> update_plan<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>child_executor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// Create a new delete executor</span>
  <span class="token keyword keyword-case">case</span> PlanType<span class="token double-colon punctuation">::</span>Delete<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> delete_plan <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> DeletePlanNode <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>plan<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 这个地方可以体现，Child的创建呈现一种递归的方式</span>
    <span class="token keyword keyword-auto">auto</span> child_executor <span class="token operator">=</span> <span class="token class-name">ExecutorFactory</span><span class="token double-colon punctuation">::</span><span class="token function">CreateExecutor</span><span class="token punctuation">(</span>exec_ctx<span class="token punctuation">,</span> delete_plan<span class="token operator">-&gt;</span><span class="token function">GetChildPlan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>DeleteExecutor<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>exec_ctx<span class="token punctuation">,</span> delete_plan<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>child_executor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上是其中部分Executor的创建方式,会递归地调用<code>ExecutorFactory::CreateExecutor</code>创建子执行器.</p>
<p>分析完了Executor的创建,我们需要关心一个Executor对象怎么调用,或者为什么要以这种方式进行调用.</p>
<blockquote>
<p><strong>采用火山模型的Executor</strong></p>
<p>这里最大的好处在于,对于不同操作类型的结点,都可以提供一致的接口被调用,也就是BusTub中的Init和Next.具有优秀的可拓展性.其中Init是该Executor的初始化操作,Next是Executor的具体执行操作.</p>
</blockquote>
<h4 id="expression">Expression</h4>
<p>许多Plan
Node需要有Expression进行“修饰”,比如说Aggregate操作中的having、group
by等,seq scan中的predicate,因此不同类型的Plan
Node也会有不同类型的Expression去修饰.</p>
<h4 id="execution-plan">Execution Plan</h4>
<p>Execution Plan的作用可以体现在,“执行器树”正是通过遍历Plan Node
Tree构造出来的,并且在执行器运行时往往需要访问其对应Plan
Node中需要的信息,比如说seq
scan中的predicate表达式等.在BusTub中,也是通过简单的多态实现的,有一个基类<code>AbstractPlanNode</code>,派生类则有<code>AggregationPlanNode、DeletePlanNode、DistinctPlanNode</code>等.</p>
<p>其中关于<code>AbstractPlanNode</code>的定义如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">AbstractPlanNode</span> <span class="token punctuation">{</span>
 <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
  <span class="token comment">/**
   * Create a new AbstractPlanNode with the specified output schema and children.
   * @param output_schema the schema for the output of this plan node
   * @param children the children of this plan node
   */</span>
  <span class="token function">AbstractPlanNode</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> Schema <span class="token operator">*</span>output_schema<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> AbstractPlanNode <span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span>children<span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">output_schema_</span><span class="token punctuation">(</span>output_schema<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">children_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">/** Virtual destructor. */</span>
  <span class="token keyword keyword-virtual">virtual</span> <span class="token operator">~</span><span class="token function">AbstractPlanNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-default">default</span><span class="token punctuation">;</span>
  <span class="token comment">/** @return the schema for the output of this plan node */</span>
  <span class="token keyword keyword-const">const</span> Schema <span class="token operator">*</span><span class="token function">OutputSchema</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> output_schema_<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment">// 返回格式</span>
  <span class="token comment">/** @return the child of this plan node at index child_idx */</span>
  <span class="token keyword keyword-const">const</span> AbstractPlanNode <span class="token operator">*</span><span class="token function">GetChildAt</span><span class="token punctuation">(</span><span class="token keyword keyword-uint32_t">uint32_t</span> child_idx<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> children_<span class="token punctuation">[</span>child_idx<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">/** @return the children of this plan node */</span>
  <span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> AbstractPlanNode <span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span><span class="token function">GetChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> children_<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">/** @return the type of this plan node */</span>
  <span class="token keyword keyword-virtual">virtual</span> PlanType <span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
  <span class="token keyword keyword-const">const</span> Schema <span class="token operator">*</span>output_schema_<span class="token punctuation">;</span>     <span class="token comment">// 返回元组的模式</span>
  <span class="token comment">/** The children of this plan node. */</span>
  std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> AbstractPlanNode <span class="token operator">*</span><span class="token operator">&gt;</span> children_<span class="token punctuation">;</span>      <span class="token comment">// 作为树的子结点</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可见<code>output_schema_、children</code>是基本的元素,前者用于限定该Plan
Node输出结果的模式,后者则是在Plan Node Tree中的子结点.</p>
<h4 id="executor">Executor</h4>
<p>在BusTub中,Executor的具体实现是lab3要做的部分,这是我当时所做的笔记:<a target="_blank" rel="noopener" href="https://yfsbox.github.io/2022/102641124.html">CMU 15-445:project
#3 - Query Execution</a>.</p>
<p>上面简要的提了一下Executor树状的特点,以及火山模型的方式.从整个系统的视角上来看,其实这里还会涉及到一些与事务、索引、并发控制相关的部分,这些部分我想在其他模块进行分析.此外,在BusTub中,这一部分采用了简单的多态实现.继承体系只有两层.其中一个基类<code>AbstractExecutor</code>,其余的<code>AggregationExecutor</code>、<code>DeleteExecutor</code>、<code>HashJoinExecutor</code>等为派生类.至于一些具体实现的东西,在上面的博客中也提到很多了,这里我只借一点具体实现的例子来强调一下执行引擎和存储引擎的交互吧.</p>
<p>其实未必所有操作类型都会涉及到对存储引擎的直接读写.只有<code>DeleteExecutor、InsertExecutor、SeqScanExecutor、UpdateExecutor</code>会直接调用存储引擎接口的.这些操作所依赖的数据往往需要从disk(或者buffer)拉取,或者对这些数据需要写入到数据库中.而其他类型的Executor所依赖的数据往往不是数据库中的“实体数据“,是一些从子执行器中生成的,因此也不会直接访问存储引擎.</p>
<p>对于直接访问存储引擎的情况,以<code>DeleteExecutor</code>为例:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-bool">bool</span> <span class="token class-name">DeleteExecutor</span><span class="token double-colon punctuation">::</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>maybe_unused<span class="token punctuation">]</span><span class="token punctuation">]</span> Tuple <span class="token operator">*</span>tuple<span class="token punctuation">,</span> RID <span class="token operator">*</span>rid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Tuple tmp_tup<span class="token punctuation">;</span>
  RID tmp_rid<span class="token punctuation">;</span>
  Transaction <span class="token operator">*</span>txn <span class="token operator">=</span> exec_ctx_<span class="token operator">-&gt;</span><span class="token function">GetTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-auto">auto</span> indexes <span class="token operator">=</span> AbstractExecutor<span class="token double-colon punctuation">::</span>exec_ctx_<span class="token operator">-&gt;</span><span class="token function">GetCatalog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">GetTableIndexes</span><span class="token punctuation">(</span>info_<span class="token operator">-&gt;</span>name_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>child_executor_<span class="token operator">-&gt;</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmp_tup<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tmp_rid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 每次遍历都会删除一个，并且需要将有关的Index项也删除</span>
    <span class="token keyword keyword-try">try</span> <span class="token punctuation">{</span>
      <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>txn<span class="token operator">-&gt;</span><span class="token function">IsSharedLocked</span><span class="token punctuation">(</span>tmp_rid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        exec_ctx_<span class="token operator">-&gt;</span><span class="token function">GetLockManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">LockUpgrade</span><span class="token punctuation">(</span>txn<span class="token punctuation">,</span> tmp_tup<span class="token punctuation">.</span><span class="token function">GetRid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        exec_ctx_<span class="token operator">-&gt;</span><span class="token function">GetLockManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">LockExclusive</span><span class="token punctuation">(</span>txn<span class="token punctuation">,</span> tmp_tup<span class="token punctuation">.</span><span class="token function">GetRid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      txn<span class="token operator">-&gt;</span><span class="token function">AddIntoDeletedPageSet</span><span class="token punctuation">(</span>tmp_tup<span class="token punctuation">.</span><span class="token function">GetRid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetPageId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      info_<span class="token operator">-&gt;</span>table_<span class="token operator">-&gt;</span><span class="token function">MarkDelete</span><span class="token punctuation">(</span>tmp_rid<span class="token punctuation">,</span> AbstractExecutor<span class="token double-colon punctuation">::</span>exec_ctx_<span class="token operator">-&gt;</span><span class="token function">GetTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 最初只是调用Mark Delete</span>
      <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> index <span class="token operator">:</span> indexes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        IndexWriteRecord <span class="token function">index_record</span><span class="token punctuation">(</span>tmp_rid<span class="token punctuation">,</span> info_<span class="token operator">-&gt;</span>oid_<span class="token punctuation">,</span> WType<span class="token double-colon punctuation">::</span>DELETE<span class="token punctuation">,</span> tmp_tup<span class="token punctuation">,</span> index<span class="token operator">-&gt;</span>index_oid_<span class="token punctuation">,</span>
                                      exec_ctx_<span class="token operator">-&gt;</span><span class="token function">GetCatalog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        txn<span class="token operator">-&gt;</span><span class="token function">AppendTableWriteRecord</span><span class="token punctuation">(</span>index_record<span class="token punctuation">)</span><span class="token punctuation">;</span>
        index<span class="token operator">-&gt;</span>index_<span class="token operator">-&gt;</span><span class="token function">DeleteEntry</span><span class="token punctuation">(</span>       <span class="token comment">// 对Index上的更新，也就是将其对应的Index项移除</span>
            tmp_tup<span class="token punctuation">.</span><span class="token function">KeyFromTuple</span><span class="token punctuation">(</span>info_<span class="token operator">-&gt;</span>schema_<span class="token punctuation">,</span> index<span class="token operator">-&gt;</span>key_schema_<span class="token punctuation">,</span> index<span class="token operator">-&gt;</span>index_<span class="token operator">-&gt;</span><span class="token function">GetKeyAttrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tmp_rid<span class="token punctuation">,</span>
            AbstractExecutor<span class="token double-colon punctuation">::</span>exec_ctx_<span class="token operator">-&gt;</span><span class="token function">GetTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>txn<span class="token operator">-&gt;</span><span class="token function">GetIsolationLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> IsolationLevel<span class="token double-colon punctuation">::</span>REPEATABLE_READ<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        exec_ctx_<span class="token operator">-&gt;</span><span class="token function">GetLockManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">Unlock</span><span class="token punctuation">(</span>txn<span class="token punctuation">,</span> tmp_tup<span class="token punctuation">.</span><span class="token function">GetRid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-catch">catch</span> <span class="token punctuation">(</span>TransactionAbortException <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword keyword-return">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword keyword-return">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中会对该table调用MarkDelete,<strong>该方法来源于存储引擎中Catalog中的TableInfo对象</strong>,更往底层深入,则会涉及到Buffer
Pool对Page的操作.像<code>InsertExecutor、UpdateExecutor</code>也是以类似的方式,<code>SeqScanExecutor</code>稍微有点不同,是通过遍历<code>TableIterator</code>实现的,但是其底层也是通过Buffer
Pool对数据库进行读取.</p>
<p>至于一些不需要直接访问存储引擎的Executor,比如说:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-bool">bool</span> <span class="token class-name">LimitExecutor</span><span class="token double-colon punctuation">::</span><span class="token function">Next</span><span class="token punctuation">(</span>Tuple <span class="token operator">*</span>tuple<span class="token punctuation">,</span> RID <span class="token operator">*</span>rid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>limit_cnt_ <span class="token operator">&gt;=</span> plan_<span class="token operator">-&gt;</span><span class="token function">GetLimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  Tuple tmp_tup<span class="token punctuation">;</span>
  RID tmp_rid<span class="token punctuation">;</span>
  <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>child_executor_<span class="token operator">-&gt;</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmp_tup<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tmp_rid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>tuple <span class="token operator">=</span> tmp_tup<span class="token punctuation">;</span>
    <span class="token operator">*</span>rid <span class="token operator">=</span> tmp_rid<span class="token punctuation">;</span>
    limit_cnt_<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword keyword-return">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是其子执行器有可能会直接访问存储引擎,或者“子子执行器”中,<strong>总之,在一个“执行器树”中,必然会有对存储引擎的访问,只要是涉及到对数据库实体数据访问情况都会需要访问存储引擎,而这些“实体数据“恰恰又是所有数据操作的源.</strong></p>
<h3 id="优化器">2).优化器</h3>
<p>在BusTub中并没有涉及到优化器的实现,但是在SimpleDB中有相关的模块,这是我当初实现相关Lab时所作的博客:<a target="_blank" rel="noopener" href="https://yfsbox.github.io/2022/09031431.html">mit 6.830 数据库系统:
lab
3</a>.在这里简单地复盘一下.结合上面提到的框架图,优化器的实现不仅仅包含优化器本身,还包括statistics的收集,<strong>不过在SimpleDB中涉及Join操作的优化,即连续的Join操作.</strong></p>
<p>其中结合SimpleDB中的测试用例,我们可以得出大概这样的流程:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token keyword keyword-final">final</span> <span class="token keyword keyword-int">int</span> IO_COST <span class="token operator">=</span> <span class="token number">103</span><span class="token punctuation">;</span>	<span class="token comment">// 表示IO开销的参数</span>
    <span class="token class-name">JoinOptimizer</span> j<span class="token punctuation">;</span>	<span class="token comment">// 优化器</span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">TableStats</span><span class="token punctuation">&gt;</span></span> stats <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 每个Table都需要用到的Statistics(用于估算代价的统计数据)</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LogicalJoinNode</span><span class="token punctuation">&gt;</span></span> result<span class="token punctuation">;</span>			<span class="token comment">// 保存优化后的结果,也就是优化后的序列</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LogicalJoinNode</span><span class="token punctuation">&gt;</span></span> nodes <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 表示一个Join序列</span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> filterSelectivities <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//</span>
    <span class="token class-name">TransactionId</span> tid <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">TransactionId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建表所需要的HeapFile文件</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> smallHeapFileTuples <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">HeapFile</span> smallHeapFileA <span class="token operator">=</span> <span class="token class-name">SystemTestUtil</span><span class="token punctuation">.</span><span class="token function">createRandomHeapFile</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span>
            <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">,</span> smallHeapFileTuples<span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">HeapFile</span> smallHeapFileB <span class="token operator">=</span> <span class="token function">createDuplicateHeapFile</span><span class="token punctuation">(</span>smallHeapFileTuples<span class="token punctuation">,</span>
            <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// 创建表,注册到Catalog</span>
    <span class="token class-name">Database</span><span class="token punctuation">.</span><span class="token function">getCatalog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTable</span><span class="token punctuation">(</span>smallHeapFileA<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Database</span><span class="token punctuation">.</span><span class="token function">getCatalog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTable</span><span class="token punctuation">(</span>smallHeapFileB<span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// 为每个表创建相应的TableStats</span>
    stats<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">TableStats</span><span class="token punctuation">(</span>smallHeapFileA<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IO_COST<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stats<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">TableStats</span><span class="token punctuation">(</span>smallHeapFileB<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IO_COST<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// Put in some filter selectivities</span>
    filterSelectivities<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    filterSelectivities<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// 构造Join序列</span>
    nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> <span class="token class-name">LogicalJoinNode</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c1"</span><span class="token punctuation">,</span> <span class="token string">"c1"</span><span class="token punctuation">,</span>
            <span class="token class-name">Predicate<span class="token punctuation">.</span>Op</span><span class="token punctuation">.</span>LESS_THAN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> <span class="token class-name">LogicalJoinNode</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"c0"</span><span class="token punctuation">,</span> <span class="token string">"c0"</span><span class="token punctuation">,</span> <span class="token class-name">Predicate<span class="token punctuation">.</span>Op</span><span class="token punctuation">.</span>EQUALS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// SQL解析器</span>
    <span class="token class-name">Parser</span> p <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Parser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 代入SQL语句到Parser,并且</span>
    j <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">JoinOptimizer</span><span class="token punctuation">(</span>
            <span class="token comment">// 首先是一个通过解析SQL得来的Logical Plan node</span>
            p<span class="token punctuation">.</span><span class="token function">generateLogicalPlan</span><span class="token punctuation">(</span>
                    tid<span class="token punctuation">,</span>
                    <span class="token string">"SELECT COUNT(a.c0) FROM a, b, c, d,e,f,g,h,i WHERE a.c1 &lt; b.c1 AND b.c0 = c.c0 AND c.c1 = d.c1 AND d.c0 = e.c0 AND e.c1 = f.c1 AND f.c0 = g.c0 AND g.c1 = h.c1 AND h.c0 = i.c0;"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 完整的Join序列</span>
    result <span class="token operator">=</span> j<span class="token punctuation">.</span><span class="token function">orderJoins</span><span class="token punctuation">(</span>stats<span class="token punctuation">,</span> filterSelectivities<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 运行,获取优化的结果</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>在表创建、注册到Catalog上时,会创建相应的TableStatistic对象,也是全局可访问的.</li>
<li>Parser将SQL语句解析成Plan Node
Tree的时候,结合其中涉及的<code>TableStats</code>求出这段Join操作序列的最低开销顺序.</li>
</ul>
<h4 id="statistics">Statistics</h4>
<p>SimpleDB中有一个<code>TableStats</code>类,一个<code>TableStats</code>对象为当前已经创建过的某个Table维护一些需要被Optimizer用到的信息,SimpleDB中有一个全局的TableStats
Map.一个表的TableStats对象会在表创建时进行初始化,当Table被更新时,其中的内容也会有相应的更新.一个<code>TableStats</code>对象的数据成员如下:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword keyword-private">private</span> <span class="token keyword keyword-int">int</span> tableId_<span class="token punctuation">;</span>
<span class="token keyword keyword-private">private</span> <span class="token class-name">HeapFile</span> tableFile_<span class="token punctuation">;</span>        <span class="token comment">// 对应的是一个表</span>
<span class="token keyword keyword-private">private</span> <span class="token class-name">TupleDesc</span> tableDesc_<span class="token punctuation">;</span>
<span class="token keyword keyword-private">private</span> <span class="token keyword keyword-int">int</span> ioCostPerPage_<span class="token punctuation">;</span>			<span class="token comment">// 访问表中的每个Page所带来的IO开销</span>
<span class="token keyword keyword-private">private</span> <span class="token keyword keyword-int">int</span> tupleNum_<span class="token punctuation">;</span>					<span class="token comment">// 一个表中的Tuple数量</span>
<span class="token keyword keyword-private">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">Field</span><span class="token punctuation">&gt;</span></span> maxValues_<span class="token punctuation">;</span>          <span class="token comment">// Int的最大值和最小值，每个Field都有一个</span>
<span class="token keyword keyword-private">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">Field</span><span class="token punctuation">&gt;</span></span> minValues_<span class="token punctuation">;</span>
<span class="token keyword keyword-private">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">IntHistogram</span><span class="token punctuation">&gt;</span></span> intHisMap_<span class="token punctuation">;</span>			<span class="token comment">// Int字段的直方图</span>
<span class="token keyword keyword-private">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">StringHistogram</span><span class="token punctuation">&gt;</span></span> strHisMap_<span class="token punctuation">;</span>	<span class="token comment">// string字段的直方图</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之所以需要将<code>tupleNum_</code>设置为一个数据成员,有利于后面在进行两个表的Join时,快速得到其中的Tuple数,在Hash
Join中,两个表的Tuple数量是其估算开销的关键,<code>ioCostPerPage_</code>则会被用于估算Join开销的公式中.当该Table中有Tuple更新时,其中直方图和极值都需要更新.当Optimizer运行的时候,会访问当前所涉及到的表的<code>TableStats</code>,从而估算出开销.</p>
<h4 id="optimizer">Optimizer</h4>
<p>优化器()工作的核心逻辑如下:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword keyword-public">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LogicalJoinNode</span><span class="token punctuation">&gt;</span></span> <span class="token function">orderJoins</span><span class="token punctuation">(</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">TableStats</span><span class="token punctuation">&gt;</span></span> stats<span class="token punctuation">,</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> filterSelectivities<span class="token punctuation">,</span> <span class="token keyword keyword-boolean">boolean</span> explain<span class="token punctuation">)</span>
        <span class="token keyword keyword-throws">throws</span> <span class="token class-name">ParsingException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里采用了一种动态规划的方式，根据Join运算的可结合性</span>
    <span class="token keyword keyword-int">int</span> n <span class="token operator">=</span> joins<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">PlanCache</span> planCache <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">PlanCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//从长度为1到长度为n</span>
        <span class="token comment">// 从0开始，size为i的子段</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">LogicalJoinNode</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> subsets <span class="token operator">=</span> <span class="token function">enumerateSubsets</span><span class="token punctuation">(</span>joins<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 一个有长度为i的子段所组成的集合</span>
        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">LogicalJoinNode</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> subsetIt <span class="token operator">=</span> subsets<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 枚举这些长度为i的子段</span>
        <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>subsetIt<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//内部分别对应一段集合</span>
            <span class="token keyword keyword-double">double</span> optcost <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LogicalJoinNode</span><span class="token punctuation">&gt;</span></span> bestList <span class="token operator">=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-int">int</span> card <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LogicalJoinNode</span><span class="token punctuation">&gt;</span></span> nodeSet <span class="token operator">=</span> subsetIt<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 获取当前node一项</span>
            <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LogicalJoinNode</span><span class="token punctuation">&gt;</span></span> setIt <span class="token operator">=</span> nodeSet<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 从该node开始</span>
            <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>setIt<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// 遍历该子段</span>
                <span class="token class-name">LogicalJoinNode</span> node <span class="token operator">=</span> setIt<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 取出该子段作为分割点</span>
                <span class="token class-name">CostCard</span> csa <span class="token operator">=</span> <span class="token function">computeCostAndCardOfSubplan</span><span class="token punctuation">(</span>stats<span class="token punctuation">,</span>filterSelectivities<span class="token punctuation">,</span>node<span class="token punctuation">,</span>nodeSet<span class="token punctuation">,</span>optcost<span class="token punctuation">,</span>planCache<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>csa <span class="token operator">!=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 是否需要更新</span>
                    optcost <span class="token operator">=</span> csa<span class="token punctuation">.</span>cost<span class="token punctuation">;</span>
                    bestList <span class="token operator">=</span> csa<span class="token punctuation">.</span>plan<span class="token punctuation">;</span>
                    card <span class="token operator">=</span> csa<span class="token punctuation">.</span>card<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            planCache<span class="token punctuation">.</span><span class="token function">addPlan</span><span class="token punctuation">(</span>nodeSet<span class="token punctuation">,</span>optcost<span class="token punctuation">,</span>card<span class="token punctuation">,</span>bestList<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 这里的Plan Cache</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LogicalJoinNode</span><span class="token punctuation">&gt;</span></span> allSet <span class="token operator">=</span> <span class="token function">enumerateSubsets</span><span class="token punctuation">(</span>joins<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LogicalJoinNode</span><span class="token punctuation">&gt;</span></span> resultList <span class="token operator">=</span> planCache<span class="token punctuation">.</span><span class="token function">getOrder</span><span class="token punctuation">(</span>allSet<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>explain<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printJoins</span><span class="token punctuation">(</span>resultList<span class="token punctuation">,</span>planCache<span class="token punctuation">,</span>stats<span class="token punctuation">,</span>filterSelectivities<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> resultList<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于连续的Join操作,这里采用了动态规划的方式处理.</p>
<blockquote>
<p><strong>如果让我在BusTub引入优化器(Join
Optimizer)模块,应该怎么做?</strong></p>
<p>首先对于Statistics来说,我会考虑将其放置于每个表的TableInfo中,因此这一部分会在每个表创建时进行初始化.由于BusTub中字段类型要比SimpleDB多,因此就需要设置更多不同类型的直方图类,这里采用简单的多态(即一个抽象类,其他都是具体类),这一部分的实现应当会相当的繁琐.</p>
<p>对于Optimizer部分,我认为难题在于,对于一个完整的Plan Node
Tree,应当遍历一遍从中获取一段段Join操作及其根Plan,之后采用类似与SimpleDB中的算法求出“最优序列”,然后根据最优序列在Plan
Node Tree中移动相应的结点的位置.</p>
</blockquote>
<h2 id="事务与并发控制">4.事务与并发控制</h2>
<p>在BusTub中,这一部分有两个核心的模块,分别是<code>TransactionManager、LockManager</code>.前者用于维护和追踪整个数据库系统中的事务,后者用于处理事务并发访问数据时所发出的锁(行级锁)请求.<code>LockManager</code>中对于锁请求的处理深刻地影响了很多事务的特性,比如说隔离级别、两阶段锁协议等等.此外,这一部分在开发时需要在执行引擎中改动部分代码,可以说事务与并发控制模块和执行引擎本身就存在一定的交互.</p>
<p>总的来说,我认为这一部分有以下几个核心的问题:</p>
<ul>
<li>系统是如何管理一个事务的生命周期的?</li>
<li>Transaction中如何实现原子性?有关于隔离型的实现呢?</li>
<li>LockManager以怎样处理锁的方式,实现隔离级别以及两阶段锁协议的?</li>
<li>执行引擎与<code>Transaction、LockManager</code>模块的关系是什么?</li>
</ul>
<p>这些问题会在下面分析.此外,关于lab中相关模块的实现,之前所做的博客:<a target="_blank" rel="noopener" href="https://yfsbox.github.io/2022/11017476.html">CMU 15-445:project #4
- Concurrency Control</a>.</p>
<h3 id="transactiontransactionmanager">1).Transaction、TransactionManager</h3>
<p>首先对于“事务”这个概念的封装,结合BusTub中对于Transaction的封装,其中的数据成员如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-private">private</span><span class="token operator">:</span>
 TransactionState state_<span class="token punctuation">;</span>			<span class="token comment">// 状态</span>
 IsolationLevel isolation_level_<span class="token punctuation">;</span>
 std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span>id thread_id_<span class="token punctuation">;</span>  	<span class="token comment">// 线程id</span>
 txn_id_t txn_id_<span class="token punctuation">;</span>
 std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span>TableWriteRecord<span class="token operator">&gt;&gt;</span> table_write_set_<span class="token punctuation">;</span>			<span class="token comment">// 该事务所写过的table集合</span>
 std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span>IndexWriteRecord<span class="token operator">&gt;&gt;</span> index_write_set_<span class="token punctuation">;</span>			<span class="token comment">// 该事务所写过的index集合</span>
 lsn_t prev_lsn_<span class="token punctuation">;</span>
 std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span>Page <span class="token operator">*</span><span class="token operator">&gt;&gt;</span> page_set_<span class="token punctuation">;</span>				<span class="token comment">// 所新增的page的集合</span>
 std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>unordered_set<span class="token operator">&lt;</span>page_id_t<span class="token operator">&gt;&gt;</span> deleted_page_set_<span class="token punctuation">;</span>			<span class="token comment">// 所移除的page的集合</span>
 std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>unordered_set<span class="token operator">&lt;</span>RID<span class="token operator">&gt;&gt;</span> shared_lock_set_<span class="token punctuation">;</span>			<span class="token comment">// 事务当前所持有的shared锁</span>
 std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>unordered_set<span class="token operator">&lt;</span>RID<span class="token operator">&gt;&gt;</span> exclusive_lock_set_<span class="token punctuation">;</span>			<span class="token comment">// 事务当前所持有的exclusive锁</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中<code>state_</code>可以说用来管理一个事务的生命周期,<code>isolation_level_</code>表示该事务的隔离级别,隔离级别将会影响一个事务生命周期的设置,比如说“可重复读”的事务会呈现“GROWING、SHRINKING、COMMITTED、ABORTED”四种状态的生命周期,而其他隔离级别却不包含SHRINKING.下面的几个set,比如<code>table_write_set_,index_write_set_,deleted_page_set_,page_set_</code>都与事务原子性相关的实现,有关,因为“要么都做,要么一点都不做”,对于abort的事务需要进行回滚,在回滚时就通过记录在这些set中的信息进行.</p>
<p>Transaction所提供的方法很简单,通常就是对这些数据成员的setter或者getter.</p>
<p>关于<code>TransactionManager</code>,该class提供了一些控制<code>Transaction</code>的方法,并且有:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-static">static</span> std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>txn_id_t<span class="token punctuation">,</span> Transaction <span class="token operator">*</span><span class="token operator">&gt;</span> txn_map<span class="token punctuation">;</span>
<span class="token keyword keyword-static">static</span> std<span class="token double-colon punctuation">::</span>shared_mutex txn_map_mutex<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>也就是说,在数据库系统中会有一个全局的map跟踪整个系统中所存在的事务,往往也是外界访问某些事务的接口.至于其中所提供的控制<code>Transaction</code>的方法,核心有:<code>Begin、Commit、Abort</code>,这与对某个事务生命周期的管理相关.</p>
<p>其中Begin,主要是创建并初始化一个<code>Transaction</code>对象,并将其记录在<code>txn_map</code>中.<code>Commit、Abort</code>的实现与事务的原子性有关:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">TransactionManager</span><span class="token double-colon punctuation">::</span><span class="token function">Commit</span><span class="token punctuation">(</span>Transaction <span class="token operator">*</span>txn<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 设置事务状态</span>
  txn<span class="token operator">-&gt;</span><span class="token function">SetState</span><span class="token punctuation">(</span>TransactionState<span class="token double-colon punctuation">::</span>COMMITTED<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Perform all deletes before we commit.</span>
  <span class="token keyword keyword-auto">auto</span> write_set <span class="token operator">=</span> txn<span class="token operator">-&gt;</span><span class="token function">GetWriteSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>write_set<span class="token operator">-&gt;</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 因为delete操作的特殊性，所以多一步遍历，用来完整地将delete操作做完</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>item <span class="token operator">=</span> write_set<span class="token operator">-&gt;</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> table <span class="token operator">=</span> item<span class="token punctuation">.</span>table_<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>wtype_ <span class="token operator">==</span> WType<span class="token double-colon punctuation">::</span>DELETE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Note that this also releases the lock when holding the page latch.</span>
      table<span class="token operator">-&gt;</span><span class="token function">ApplyDelete</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>rid_<span class="token punctuation">,</span> txn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    write_set<span class="token operator">-&gt;</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  write_set<span class="token operator">-&gt;</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">ReleaseLocks</span><span class="token punctuation">(</span>txn<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 释放所有锁</span>
  global_txn_latch_<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Commit</code>意味着一个事务中的动作全部完成.由于存储引擎中对于Delete的处理是两段式的,因此这里需要根据<code>write_set</code>中的记录对这些Delete操作进行apply.之后将所有锁进行释放.</p>
<p>而<code>Abort</code>的实现相对来说比较复杂,这意味着“全部都不做”,因此需要回滚.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">TransactionManager</span><span class="token double-colon punctuation">::</span><span class="token function">Abort</span><span class="token punctuation">(</span>Transaction <span class="token operator">*</span>txn<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 相比Commited还会涉及到恢复</span>
  txn<span class="token operator">-&gt;</span><span class="token function">SetState</span><span class="token punctuation">(</span>TransactionState<span class="token double-colon punctuation">::</span>ABORTED<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Rollback before releasing the lock.</span>
  <span class="token keyword keyword-auto">auto</span> table_write_set <span class="token operator">=</span> txn<span class="token operator">-&gt;</span><span class="token function">GetWriteSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>table_write_set<span class="token operator">-&gt;</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>item <span class="token operator">=</span> table_write_set<span class="token operator">-&gt;</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> table <span class="token operator">=</span> item<span class="token punctuation">.</span>table_<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>wtype_ <span class="token operator">==</span> WType<span class="token double-colon punctuation">::</span>DELETE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      table<span class="token operator">-&gt;</span><span class="token function">RollbackDelete</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>rid_<span class="token punctuation">,</span> txn<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 恢复</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>wtype_ <span class="token operator">==</span> WType<span class="token double-colon punctuation">::</span>INSERT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 移除</span>
      <span class="token comment">// Note that this also releases the lock when holding the page latch.</span>
      table<span class="token operator">-&gt;</span><span class="token function">ApplyDelete</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>rid_<span class="token punctuation">,</span> txn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>wtype_ <span class="token operator">==</span> WType<span class="token double-colon punctuation">::</span>UPDATE<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 换成旧的</span>
      table<span class="token operator">-&gt;</span><span class="token function">UpdateTuple</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>tuple_<span class="token punctuation">,</span> item<span class="token punctuation">.</span>rid_<span class="token punctuation">,</span> txn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    table_write_set<span class="token operator">-&gt;</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  table_write_set<span class="token operator">-&gt;</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Rollback index updates</span>
  <span class="token keyword keyword-auto">auto</span> index_write_set <span class="token operator">=</span> txn<span class="token operator">-&gt;</span><span class="token function">GetIndexWriteSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>index_write_set<span class="token operator">-&gt;</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 将Index进行修改</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>item <span class="token operator">=</span> index_write_set<span class="token operator">-&gt;</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> catalog <span class="token operator">=</span> item<span class="token punctuation">.</span>catalog_<span class="token punctuation">;</span>
    <span class="token comment">// Metadata identifying the table that should be deleted from.</span>
    TableInfo <span class="token operator">*</span>table_info <span class="token operator">=</span> catalog<span class="token operator">-&gt;</span><span class="token function">GetTable</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>table_oid_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    IndexInfo <span class="token operator">*</span>index_info <span class="token operator">=</span> catalog<span class="token operator">-&gt;</span><span class="token function">GetIndex</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>index_oid_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> new_key <span class="token operator">=</span> item<span class="token punctuation">.</span>tuple_<span class="token punctuation">.</span><span class="token function">KeyFromTuple</span><span class="token punctuation">(</span>table_info<span class="token operator">-&gt;</span>schema_<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>index_info<span class="token operator">-&gt;</span>index_<span class="token operator">-&gt;</span><span class="token function">GetKeySchema</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                            index_info<span class="token operator">-&gt;</span>index_<span class="token operator">-&gt;</span><span class="token function">GetKeyAttrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>wtype_ <span class="token operator">==</span> WType<span class="token double-colon punctuation">::</span>DELETE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      index_info<span class="token operator">-&gt;</span>index_<span class="token operator">-&gt;</span><span class="token function">InsertEntry</span><span class="token punctuation">(</span>new_key<span class="token punctuation">,</span> item<span class="token punctuation">.</span>rid_<span class="token punctuation">,</span> txn<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 做逆操作</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>wtype_ <span class="token operator">==</span> WType<span class="token double-colon punctuation">::</span>INSERT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      index_info<span class="token operator">-&gt;</span>index_<span class="token operator">-&gt;</span><span class="token function">DeleteEntry</span><span class="token punctuation">(</span>new_key<span class="token punctuation">,</span> item<span class="token punctuation">.</span>rid_<span class="token punctuation">,</span> txn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>wtype_ <span class="token operator">==</span> WType<span class="token double-colon punctuation">::</span>UPDATE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Delete the new key and insert the old key</span>
      index_info<span class="token operator">-&gt;</span>index_<span class="token operator">-&gt;</span><span class="token function">DeleteEntry</span><span class="token punctuation">(</span>new_key<span class="token punctuation">,</span> item<span class="token punctuation">.</span>rid_<span class="token punctuation">,</span> txn<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword keyword-auto">auto</span> old_key <span class="token operator">=</span> item<span class="token punctuation">.</span>old_tuple_<span class="token punctuation">.</span><span class="token function">KeyFromTuple</span><span class="token punctuation">(</span>table_info<span class="token operator">-&gt;</span>schema_<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>index_info<span class="token operator">-&gt;</span>index_<span class="token operator">-&gt;</span><span class="token function">GetKeySchema</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                                  index_info<span class="token operator">-&gt;</span>index_<span class="token operator">-&gt;</span><span class="token function">GetKeyAttrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      index_info<span class="token operator">-&gt;</span>index_<span class="token operator">-&gt;</span><span class="token function">InsertEntry</span><span class="token punctuation">(</span>old_key<span class="token punctuation">,</span> item<span class="token punctuation">.</span>rid_<span class="token punctuation">,</span> txn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    index_write_set<span class="token operator">-&gt;</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  table_write_set<span class="token operator">-&gt;</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  index_write_set<span class="token operator">-&gt;</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Release all the locks.</span>
  <span class="token function">ReleaseLocks</span><span class="token punctuation">(</span>txn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将所有锁释放掉</span>
  <span class="token comment">// Release the global transaction latch.</span>
  global_txn_latch_<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这其中的回滚需要涉及到对写过的Table的回滚,以及Index回滚.回滚实质上就是做逆操作,对于某些逆操作需要根据保存的“旧值”进行,比如说UpdateTuple以及Index的Update等.而这些信息都会保存在<code>TableWriteRecord</code>或者<code>IndexWriteRecord</code>中,<strong>关于这些”WriteRecord“对象,都会在执行器做相关的操作时生成,并加入到该事务的set中</strong>.</p>
<p>至此,关于原子性的实现,可以说:<strong>Transaction中会维护有关于Table、Index的WriteRecord,在执行器运行时(Next)中,比如DeleteExecutor、UpdateExecutor等,会在其关联的Transaction中添加相关的WriteRecord.如果该事务正常结束,也就是Commit,只要对发生过的Delete进行apply就好了,这与存储引擎中的二段式Delete处理有关,如果是Abort的话,就遍历这些WriteRecord的集合,做逆操作,逐个回滚</strong>.</p>
<blockquote>
<p><strong>数据库系统是如何管理一个Transaction的生命周期的?</strong></p>
<ol type="1">
<li><p>首先通过<code>TransactionManager</code>的Begin创建一个事务,</p></li>
<li><p>随后将该事务相关的执行任务与该事务相关联,大概如下所示:</p></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token keyword keyword-auto">auto</span> exec_ctx1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>ExecutorContext<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>txn1<span class="token punctuation">,</span> <span class="token function">GetCatalog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">GetBPM</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">GetTxnManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">GetLockManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 其中有一个指向事件的指针</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
 <span class="token function">GetExecutionEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">Execute</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>insert_plan<span class="token punctuation">,</span> <span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">,</span> txn1<span class="token punctuation">,</span> exec_ctx1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>随后代入将相关的plan以及<code>ExecutorContext</code>对象代入到执行引擎中,该事件中的操作也就开始运行了(当然一个事件可以有多个plan).</p>
<ol start="3" type="1">
<li><p>最终调用Commit或者Abort.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">GetTxnManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">Abort</span><span class="token punctuation">(</span>txn1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该事件的生命周期也就结束了.</p></li>
</ol>
<p>关于生命周期这里只是笼统地说一说了,如果相结合两段锁协议等机制的话,就去看上面我写过的那篇博客就好了.</p>
</blockquote>
<h3 id="lockmanager">2).LockManager</h3>
<p>事务的隔离性需要借助Lock来实现.由于在执行器中,所涉及的事务对数据库中Tuple的读写操作需要上锁,LockManager就用于处理来自执行器中锁请求,<strong>尤其是会根据不同事务隔离级别有不同的处理方式</strong>.其实这一部分的细节,我在lab4的那篇博客里说得已经差不多,这里就不再多说了.</p>
<blockquote>
<p><strong>关于执行引擎和Transaction以及LockManager的关系?</strong></p>
<p>再执行器的接口中(Execute),需要将其所属的Transaction代入,因为在执行器执行(Next)时,需要通过访问该事务,以获取其隔离级别、锁状态等信息,从而通过调用LockManager来发送不同上锁请求.比如说,下面的这种情况:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>txn<span class="token operator">-&gt;</span><span class="token function">IsSharedLocked</span><span class="token punctuation">(</span>tmp_rid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  exec_ctx_<span class="token operator">-&gt;</span><span class="token function">GetLockManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">LockUpgrade</span><span class="token punctuation">(</span>txn<span class="token punctuation">,</span> tmp_rid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
  exec_ctx_<span class="token operator">-&gt;</span><span class="token function">GetLockManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">LockExclusive</span><span class="token punctuation">(</span>txn<span class="token punctuation">,</span> tmp_rid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于上写锁的情况,如果之前就已经占用了读锁,那么需要调用LockManager的LockUpgrade,否则就是LockExclusive.</p>
<p>除此之外,执行器在执行时还需要将WriteRecord加入到该事务相应的集合中.</p>
</blockquote>
<h3 id="小结-1">3).小结</h3>
<p>最后,为这一模块的简单的归纳几点:</p>
<ul>
<li><strong>Transaction的封装与实现.</strong>也就是说,实现一个Transaction类需要包含哪些数据成员?由于原子性的需要,事务需要维持一些Write
Record确保根据这些东西可以在Abort时撤销操作,达到“要么什么都不做”的效果.还需要追踪当前所持有的锁,这使得当调用Commit或者Abort时,将该事务的Lock释放掉.除此之外,还有隔离级别、生命状态等等.</li>
<li><strong>TransactionManager中操作事务的接口.</strong>比如Commit、Abort等,其中Abort的实现相对复杂,毕竟有撤销已写操作的需要.</li>
<li><strong>LockManager中不同的锁的类型,以及上锁、解锁、升级锁的API</strong>.这里有Shared和Exclusive两种类型,并且为行级锁(以RID为单位).对于每个RID,维护一个请求队列,并记录该RID的上锁信息、占用事务等,当执行器中有事务发出锁请求时,会加入相应的队列,通过轮询该队列的方式判断是否满足上锁条件,并借助条件变量控制事务的阻塞,达到锁的效果.</li>
<li><strong>执行引擎中,与Transaction以及LockManager的关系</strong>.简而言之,执行器必须访问其所属的事务(获取隔离级别、锁状态等),也必须通过调用LockManager中提供的锁相关API完成锁操作(因事务隔离级别而处理方式不同).</li>
</ul>
<h2 id="日志及恢复系统">5.日志及恢复系统</h2>
<p>我做的是2021版本的BusTub,其中没有关于这一模块的实现,据说2019版的是有这一部分,所以就找了相关的源码去研究了.这其中大致可以分为三个模块,分别是<code>LogManager、LogRecovery、CheckpointManager</code>:</p>
<ul>
<li><strong>日志系统</strong>,其中主要在于日志文件的组织方式,数据库系统中如何、何时输出日志,日志系统的工作模式等问题.</li>
<li><strong>检查点</strong>,应该如何做出检查点,当打印检查点时数据库系统中其他模块都有什么样的响应.</li>
<li><strong>恢复系统</strong>,如何扫描log文件,在这个过程中如何undo和redo.</li>
</ul>
<h3 id="其他模块中的相关细节">1).其他模块中的相关细节</h3>
<h3 id="lsn">LSN</h3>
<p>lsn即日志序列号,可以视为数据库系统中对于修改操作的逻辑时钟,系统中发生过的每个修改行为都会有一个相应的lsn编号.</p>
<p>日志系统维护了一个全局的lsn编号,每当有一个修改操作发生时,就会自增,因此这也就是该修改操作所对应的lsn编号.在Page中也会有一个lsn域,对应的是该Page最新的修改动作.就像其他字段一样,Page中的lsn域首先也是在内存中修改,随后该Page从BufferPool中踢出时才会flush到数据库文件中.此外日志系统中还会记录当前成功flush到日志文件中的lsn编号.</p>
<h3 id="wal">WAL</h3>
<p><strong>数据库系统中一些机制实现的难点在于需要考虑到多个模块的交互,即多个模块彼此配合才可以实现某种特定的机制.</strong>比如说这里的WAL机制.如何保证修改记录对应的日志文件先于数据库文件写完呢?</p>
<p>首先我们需要考虑的是什么时候写数据库文件?结合BufferPool机制,当一个内存页被踢出的时候,会将该Page刷盘到数据库文件之中.结合存储引擎以及LogManager我们可以知道,当内存页被修改时同时也会生成一个LogRecord,并且调用LogManager::AppendLogRecord,由于日志系统是异步运行的,所以即使内存页已经被修改将要被踢出并flush的时候,也不能保证此时日志文件已经被flush了,<strong>因此需要在一个Page被踢出,尚未flush到数据库文件时,对日志文件进行flush</strong>.相关的代码细节如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">frame_id_t <span class="token class-name">BufferPoolManager</span><span class="token double-colon punctuation">::</span><span class="token function">GetVictimFrameId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 当一个Page需要从buffer pool中题出来时</span>
  frame_id_t frame_id<span class="token punctuation">;</span>

  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>free_list_<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    frame_id <span class="token operator">=</span> free_list_<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    free_list_<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>replacer_<span class="token operator">-&gt;</span><span class="token function">Victim</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>frame_id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword keyword-return">return</span> INVALID_PAGE_ID<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// flush log to disk when victim a dirty page</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>enable_logging<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Page <span class="token operator">&amp;</span>page <span class="token operator">=</span> pages_<span class="token punctuation">[</span>frame_id<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">IsDirty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> page<span class="token punctuation">.</span><span class="token function">GetLSN</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> log_manager_<span class="token operator">-&gt;</span><span class="token function">GetPersistentLSN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log_manager_<span class="token operator">-&gt;</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword keyword-return">return</span> frame_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过"log_manager_-&gt;GetPersistentLSN"可以得知当前日志文件已经flush完的lsn编号,如果该内存页中的lsn编号大于它,说明还有尚未flush完的日志记录.</p>
<h3 id="logmanager">2).LogManager</h3>
<p>这里日志系统的实现比较简陋,比muduo的日志系统要简单得多,但总得来说还是采用了前后端的模式,前端被user
code(一般是数据库系统的其他部分,比如说执行引擎)调用构造日志消息,后端接收到这些日志消息,每隔一定阶段就将日志消息刷到日志文件中(往往是前端buffer写满的时候).</p>
<p>再LogManager对象中,重点在于两个buffer:<strong>log_buffer,flush_buffer</strong>,一个用于接收来自日志前端的日志消息,另一个则是在log_buffer写满之后,将其转移到flush_buffer中,后端日志线程将其flush到日志文件之中.</p>
<p>关于前端,提供了一个<code>LogManager::AppendLogRecord</code>接口,相关的代码如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">lsn_t <span class="token class-name">LogManager</span><span class="token double-colon punctuation">::</span><span class="token function">AppendLogRecord</span><span class="token punctuation">(</span>LogRecord <span class="token operator">*</span>log_record<span class="token punctuation">)</span> <span class="token punctuation">{</span>      
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>latch_<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// flush log to disk when the log buffer is full</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>log_record<span class="token operator">-&gt;</span>size_ <span class="token operator">+</span> log_buffer_offset_ <span class="token operator">&gt;</span> LOG_BUFFER_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// wake up flush thread to write log</span>
    need_flush_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    cv_<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 唤醒后台线程,首先flush掉,将flush buffer中的消息消费掉,否则现在buffer就是满的</span>
    <span class="token comment">// block current thread until log buffer is emptied</span>
    cv_append_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> log_record<span class="token operator">-&gt;</span>size_ <span class="token operator">+</span> log_buffer_offset_ <span class="token operator">&lt;=</span> LOG_BUFFER_SIZE<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>     <span class="token comment">// 等待可以被消费掉</span>
  <span class="token comment">// serialize header</span>
  <span class="token comment">// 将header的内容进行序列化</span>
  log_record<span class="token operator">-&gt;</span>lsn_ <span class="token operator">=</span> next_lsn_<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment">// 内存中会追踪lsn,也就是日志版本号</span>
  <span class="token function">memcpy</span><span class="token punctuation">(</span>log_buffer_ <span class="token operator">+</span> log_buffer_offset_<span class="token punctuation">,</span> log_record<span class="token punctuation">,</span> LogRecord<span class="token double-colon punctuation">::</span>HEADER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 相当于直接append</span>
  <span class="token keyword keyword-int">int</span> pos <span class="token operator">=</span> log_buffer_offset_ <span class="token operator">+</span> LogRecord<span class="token double-colon punctuation">::</span>HEADER_SIZE<span class="token punctuation">;</span>      <span class="token comment">// 并且获取了append之后的header_size</span>
  <span class="token keyword keyword-switch">switch</span> <span class="token punctuation">(</span>log_record<span class="token operator">-&gt;</span><span class="token function">GetLogRecordType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 			<span class="token keyword keyword-case">case</span> LogRecordType<span class="token double-colon punctuation">::</span>INSERT<span class="token operator">:</span>
      <span class="token function">memcpy</span><span class="token punctuation">(</span>log_buffer_ <span class="token operator">+</span> pos<span class="token punctuation">,</span> <span class="token operator">&amp;</span>log_record<span class="token operator">-&gt;</span>insert_rid_<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>RID<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      pos <span class="token operator">+=</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>RID<span class="token punctuation">)</span><span class="token punctuation">;</span>
      log_record<span class="token operator">-&gt;</span>insert_tuple_<span class="token punctuation">.</span><span class="token function">SerializeTo</span><span class="token punctuation">(</span>log_buffer_ <span class="token operator">+</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 将其中剩余的内容序列化</span>
      <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
  log_buffer_offset_ <span class="token operator">+=</span> log_record<span class="token operator">-&gt;</span>size_<span class="token punctuation">;</span>      <span class="token comment">// 移动缓冲区中的offset</span>
  <span class="token keyword keyword-return">return</span> log_record<span class="token operator">-&gt;</span>lsn_<span class="token punctuation">;</span>      <span class="token comment">// 返回标号</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先需要检查log_buffer中是否还有足够的空间写入该log_record,如果没有足够的空间,就唤醒正在等待的后台日志线程(会将log_buffer的内容“消费”到flush_buffer中),并且借助条件变量等待log_buffer有足够的空间.之后设置这条日志消息的lsn编号,并且将日志消息的header写入.之后根据日志消息的类型进行特定的写入(写入到log_record).写完之后需要移动log_buffer的偏移量.</p>
<p>至于日志系统中后台线程,及其运行逻辑:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">LogManager</span><span class="token double-colon punctuation">::</span><span class="token function">RunFlushThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 运行后台的log thread</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>enable_logging<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 实现还是比较简陋的</span>
    <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  enable_logging <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  flush_thread_ <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>enable_logging<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>latch_<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// flush log to disk if log time out or log buffer is full</span>
      cv_<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> log_timeout<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> need_flush_<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>log_buffer_offset_ <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>log_buffer_<span class="token punctuation">,</span> flush_buffer_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>log_buffer_offset_<span class="token punctuation">,</span> flush_buffer_offset_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        disk_manager_<span class="token operator">-&gt;</span><span class="token function">WriteLog</span><span class="token punctuation">(</span>flush_buffer_<span class="token punctuation">,</span> flush_buffer_offset_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        flush_buffer_offset_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">SetPersistentLSN</span><span class="token punctuation">(</span>next_lsn_ <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// flush完之后,就设置persistentLSN</span>
      <span class="token punctuation">}</span>

      need_flush_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      cv_append_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>后台日志线程中,会使用条件变量等待log_buffer写满,等待被唤醒之后,将log_buffer中内容借助disk_manager将日志消息写入到日志文件.其中维护了变量<code>persistent_lsn_</code>,改变量指的是当前已经成功写入到日志文件之中的lsn编号.</p>
<blockquote>
<p><strong>BusTub中日志系统的缺点</strong></p>
<p>这个日志系统相对来说是比较简陋的,主要原因在于User
Thread(就是调用LogManager::AppendLogRecord的线程)会因为等待后台线程消费而陷入阻塞.muduo中的日志系统正是为了解决这个问题而设计了双缓冲机制.</p>
</blockquote>
<p><strong>LogManager还会为每个日志消息指定日志序列号(lsn).</strong></p>
<blockquote>
<p><strong>BusTub中打印日志的时机</strong></p>
<ul>
<li>一个事务开始的时候会有一个BEGIN类型的日志消息.</li>
<li>一个事务结束的时候,也就是Commit或者Abort的时候.</li>
<li>事务在运行期间.具体地说,是存储引擎中TablePage中的相关接口被调用时.例如<code>TablePage::ApplyDelete</code>中有:</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>enable_logging<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">BUSTUB_ASSERT</span><span class="token punctuation">(</span>txn<span class="token operator">-&gt;</span><span class="token function">IsExclusiveLocked</span><span class="token punctuation">(</span>rid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"We must own the exclusive lock!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  LogRecord <span class="token function">log_record</span><span class="token punctuation">(</span>txn<span class="token operator">-&gt;</span><span class="token function">GetTransactionId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> txn<span class="token operator">-&gt;</span><span class="token function">GetPrevLSN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> LogRecordType<span class="token double-colon punctuation">::</span>APPLYDELETE<span class="token punctuation">,</span> rid<span class="token punctuation">,</span> delete_tuple<span class="token punctuation">)</span><span class="token punctuation">;</span>
  lsn_t lsn <span class="token operator">=</span> log_manager<span class="token operator">-&gt;</span><span class="token function">AppendLogRecord</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>log_record<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">SetLSN</span><span class="token punctuation">(</span>lsn<span class="token punctuation">)</span><span class="token punctuation">;</span>
  txn<span class="token operator">-&gt;</span><span class="token function">SetPrevLSN</span><span class="token punctuation">(</span>lsn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<h3 id="checkpointmanager">3).CheckpointManager</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token class-name">CheckpointManager</span><span class="token double-colon punctuation">::</span><span class="token function">BeginCheckpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  transaction_manager_<span class="token operator">-&gt;</span><span class="token function">BlockAllTransactions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 阻塞当前的所有事件</span>
  log_manager_<span class="token operator">-&gt;</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 强制性地刷盘</span>
  buffer_pool_manager_<span class="token operator">-&gt;</span><span class="token function">FlushAllPages</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 将buffer pool中的刷到磁盘上</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token class-name">CheckpointManager</span><span class="token double-colon punctuation">::</span><span class="token function">EndCheckpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Allow transactions to resume, completing the checkpoint.</span>
  transaction_manager_<span class="token operator">-&gt;</span><span class="token function">ResumeTransactions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 结束掉一个检查点</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在数据库系统中,通常会每隔一定的周期就建立一个检查点,建立检查点的作用在于避免恢复时从头到尾扫描日志文件而带来冗余的恢复操作.BusTub在建立检查点时,调用BeginCheckpoint,会阻塞新的事务建立并运行,之后强制性地将log_manager、buffer_pool中的数据进行flush.当这些flush完毕之后,调用EndCheckpoint,接触新事务的阻塞,数据库系统之后正常运行.</p>
<p>其中体现了数据库系统<strong>先写日志文件,再写数据库文件的特点</strong>.</p>
<h3 id="logrecovery">4).LogRecovery</h3>
<p>LogRecovery将会扫描日志文件,并且通过undo、redo操作来执行日志恢复操作.其提供的相关接口主要也是<code>Undo、Redo</code>.基于<code>LogRecovery</code>的恢复动作很简单:先调用Redo再调用Undo就可以了.</p>
<p>当Redo时,会扫描日志文件中的每条记录,并比对该Page中的lsn和日志记录中的lsn,如果Page中的lsn编号较小,就需要重做,<strong>这对应了只写了日志文件,没来得及写数据库文件就宕机的情况</strong>.与此同时还会收集“活跃事务”,也就是直到系统崩溃还没有完成的事务,也就是在扫描时,如果没有扫描到该事务的Commit或者Abort记录,就会被判定为“活跃事务”.</p>
<p>当Undo时,将之前收集的活跃事务中的操作撤销.</p>
<h3 id="小结-2">5).小结</h3>
<p>总的来说,我认为这一部分的核心在于对lsn相关操作的理解和把握.</p>
<h2 id="思考怎样写一个数据库">6.思考:怎样写一个数据库?</h2>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.</span> <span class="toc-text">1.存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">1).内存模型与类型抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#value%E4%B8%8Etype"><span class="toc-number">1.1.1.</span> <span class="toc-text">value与type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tuple"><span class="toc-number">1.1.2.</span> <span class="toc-text">tuple</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E9%A1%B5"><span class="toc-number">1.2.</span> <span class="toc-text">2).文件分页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tablepage"><span class="toc-number">1.2.1.</span> <span class="toc-text">TablePage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tableheap"><span class="toc-number">1.2.2.</span> <span class="toc-text">TableHeap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.</span> <span class="toc-text">3).全局元数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98io"><span class="toc-number">1.4.</span> <span class="toc-text">4).磁盘I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-number">1.5.</span> <span class="toc-text">5).缓存池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text">6).小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">2.索引系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">1).内存数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="toc-number">2.2.</span> <span class="toc-text">2).索引文件组织</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="toc-number">3.</span> <span class="toc-text">3.查询与执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-number">3.1.</span> <span class="toc-text">1).执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#execution-engine"><span class="toc-number">3.1.1.</span> <span class="toc-text">Execution Engine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#expression"><span class="toc-number">3.1.2.</span> <span class="toc-text">Expression</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execution-plan"><span class="toc-number">3.1.3.</span> <span class="toc-text">Execution Plan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#executor"><span class="toc-number">3.1.4.</span> <span class="toc-text">Executor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2).优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#statistics"><span class="toc-number">3.2.1.</span> <span class="toc-text">Statistics</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#optimizer"><span class="toc-number">3.2.2.</span> <span class="toc-text">Optimizer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">4.事务与并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transactiontransactionmanager"><span class="toc-number">4.1.</span> <span class="toc-text">1).Transaction、TransactionManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lockmanager"><span class="toc-number">4.2.</span> <span class="toc-text">2).LockManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">4.3.</span> <span class="toc-text">3).小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%8F%8A%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">5.日志及恢复系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%86%E8%8A%82"><span class="toc-number">5.1.</span> <span class="toc-text">1).其他模块中的相关细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsn"><span class="toc-number">5.2.</span> <span class="toc-text">LSN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wal"><span class="toc-number">5.3.</span> <span class="toc-text">WAL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#logmanager"><span class="toc-number">5.4.</span> <span class="toc-text">2).LogManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#checkpointmanager"><span class="toc-number">5.5.</span> <span class="toc-text">3).CheckpointManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#logrecovery"><span class="toc-number">5.6.</span> <span class="toc-text">4).LogRecovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">5.7.</span> <span class="toc-text">5).小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E6%80%8E%E6%A0%B7%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">6.</span> <span class="toc-text">6.思考:怎样写一个数据库?</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/012241324.html"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/012241324.html&text=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/012241324.html&title=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/012241324.html&is_video=false&description=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=结合SimpleDB和BusTub复盘数据库内核实现&body=Check out this article: http://example.com/2023/012241324.html"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/012241324.html&title=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/012241324.html&title=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/012241324.html&title=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/012241324.html&title=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/012241324.html&name=结合SimpleDB和BusTub复盘数据库内核实现&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/012241324.html&t=结合SimpleDB和BusTub复盘数据库内核实现"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    yfs
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
      --><li><a href="/">首页</a></li><!--
    --><!--
      --><li><a href="/about/">关于</a></li><!--
    --><!--
      --><li><a href="/archives/">归档</a></li><!--
    -->
      </ul>
      <ul>
        
          <!-- 不蒜子统计 -->
          <span id="busuanzi_container_site_pv">
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
          </span>
          <span class="post-meta-divider">|</span>
          <span id="busuanzi_container_site_uv" style='display:none'>
                  本站访客数<span id="busuanzi_value_site_uv"></span>人
          </span>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        
      </ul>
    </nav>
  </div>
  
</footer>

<script src="/js/prism/prism.js" async></script>


    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'cactus-1';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'owner/githubrepo';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>
